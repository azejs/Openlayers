import {
  MapBrowserEvent_default,
  MapEvent_default,
  all,
  altKeyOnly,
  altShiftKeysOnly,
  always,
  focusWithTabindex,
  mouseActionButton,
  mouseOnly,
  never,
  noModifierKeys,
  primaryAction,
  shiftKeyOnly,
  singleClick,
  targetNotEditable
} from "./chunk-K5H6VQZU.js";
import {
  Vector_default as Vector_default2
} from "./chunk-3LJ5YHNJ.js";
import {
  Vector_default
} from "./chunk-TCBQFITY.js";
import "./chunk-2B7WBQIR.js";
import {
  Interaction_default,
  MapBrowserEventType_default,
  Pointer_default,
  Property_default,
  centroid,
  pan,
  zoomByDelta
} from "./chunk-AGQWMEDT.js";
import {
  RBush_default,
  VectorEventType_default
} from "./chunk-4EXALPVZ.js";
import {
  Feature_default,
  LineString_default
} from "./chunk-YTNHGD7O.js";
import {
  Point_default,
  Polygon_default,
  circular,
  fromCircle,
  fromExtent
} from "./chunk-QSABLXA5.js";
import {
  GroupEvent,
  Group_default
} from "./chunk-F34KZBPW.js";
import {
  Collection_default
} from "./chunk-JXIYK5ME.js";
import {
  CollectionEventType_default
} from "./chunk-BVELFQ75.js";
import {
  ImageCanvas_default
} from "./chunk-4IRI6BPY.js";
import {
  CLASS_COLLAPSED,
  CLASS_CONTROL,
  CLASS_HIDDEN,
  CLASS_SELECTABLE,
  CLASS_UNSELECTABLE,
  CLASS_UNSUPPORTED,
  Fill_default,
  Immediate_default,
  Stroke_default,
  Style_default,
  Text_default,
  ViewHint_default,
  checkedFonts,
  createEditingStyle,
  getSquaredTolerance,
  shared
} from "./chunk-KJHD3YWC.js";
import "./chunk-CA6AZ6OG.js";
import "./chunk-JRGZR5VC.js";
import {
  GeometryLayout_default
} from "./chunk-5QGPZAYJ.js";
import {
  EventType_default as EventType_default2,
  Event_default as Event_default2,
  Layer_default,
  inView
} from "./chunk-2WFBQUZT.js";
import {
  apply,
  compose,
  create,
  makeInverse,
  multiply
} from "./chunk-MV5AOD5E.js";
import "./chunk-W6MYRY4U.js";
import {
  DEFAULT_TILE_SIZE,
  TileCache_default
} from "./chunk-BNERK335.js";
import "./chunk-2JXW4BLZ.js";
import "./chunk-GDWVPC6F.js";
import {
  ImageTile_default,
  TileRange_default,
  TileState_default,
  Tile_default
} from "./chunk-UG7WNBZX.js";
import {
  easeOut,
  inAndOut
} from "./chunk-WEX2BEHQ.js";
import {
  ImageBase_default,
  Image_default,
  createCanvasContext2D,
  hasArea,
  outerHeight,
  outerWidth,
  releaseCanvas,
  removeChildren,
  removeNode,
  replaceChildren,
  replaceNode
} from "./chunk-6IH7H6ST.js";
import {
  DEVICE_PIXEL_RATIO,
  FIREFOX,
  PASSIVE_EVENT_LISTENERS
} from "./chunk-H2WCVIFF.js";
import {
  Disposable_default,
  EventType_default,
  Event_default,
  FALSE,
  ObjectEventType_default,
  Object_default,
  Observable_default,
  TRUE,
  Target_default,
  VOID,
  equals,
  extend,
  includes,
  linearFindNearest,
  listen,
  listenOnce,
  stopPropagation,
  unlistenByKey
} from "./chunk-NCMW2GPD.js";
import {
  METERS_PER_UNIT,
  Units_default,
  add,
  closestOnSegment,
  createProjection,
  degreesToStringHDMS,
  disableCoordinateWarning,
  distance,
  equals as equals3,
  equivalent,
  fromUserCoordinate,
  fromUserExtent,
  get,
  getPointResolution,
  getTransform,
  getTransformFromProjections,
  getUserProjection,
  identityTransform,
  rotate,
  scale,
  squaredDistance,
  squaredDistanceToSegment,
  toUserCoordinate,
  toUserExtent,
  wrapX as wrapX2
} from "./chunk-FQUMW2AY.js";
import {
  AssertionError_default,
  VERSION,
  abstract,
  applyTransform,
  approximatelyEquals,
  assert,
  assign,
  boundingExtent,
  buffer,
  clamp,
  clear,
  clone,
  containsCoordinate,
  containsExtent,
  createOrUpdateEmpty,
  createOrUpdateFromCoordinate,
  equals as equals2,
  getArea,
  getBottomRight,
  getCenter,
  getForViewAndSize,
  getHeight,
  getIntersection,
  getTopLeft,
  getUid,
  getValues,
  getWidth,
  intersects,
  isEmpty2 as isEmpty,
  modulo,
  scaleFromCenter,
  squaredSegmentDistance,
  toRadians,
  wrapX
} from "./chunk-IHVPZQIE.js";

// node_modules/ol/Geolocation.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Property = {
  ACCURACY: "accuracy",
  ACCURACY_GEOMETRY: "accuracyGeometry",
  ALTITUDE: "altitude",
  ALTITUDE_ACCURACY: "altitudeAccuracy",
  HEADING: "heading",
  POSITION: "position",
  PROJECTION: "projection",
  SPEED: "speed",
  TRACKING: "tracking",
  TRACKING_OPTIONS: "trackingOptions"
};
var GeolocationError = function(_super) {
  __extends(GeolocationError2, _super);
  function GeolocationError2(error) {
    var _this = _super.call(this, EventType_default.ERROR) || this;
    _this.code = error.code;
    _this.message = error.message;
    return _this;
  }
  return GeolocationError2;
}(Event_default);
var Geolocation = function(_super) {
  __extends(Geolocation2, _super);
  function Geolocation2(opt_options) {
    var _this = _super.call(this) || this;
    _this.on;
    _this.once;
    _this.un;
    var options = opt_options || {};
    _this.position_ = null;
    _this.transform_ = identityTransform;
    _this.watchId_ = void 0;
    _this.addChangeListener(Property.PROJECTION, _this.handleProjectionChanged_);
    _this.addChangeListener(Property.TRACKING, _this.handleTrackingChanged_);
    if (options.projection !== void 0) {
      _this.setProjection(options.projection);
    }
    if (options.trackingOptions !== void 0) {
      _this.setTrackingOptions(options.trackingOptions);
    }
    _this.setTracking(options.tracking !== void 0 ? options.tracking : false);
    return _this;
  }
  Geolocation2.prototype.disposeInternal = function() {
    this.setTracking(false);
    _super.prototype.disposeInternal.call(this);
  };
  Geolocation2.prototype.handleProjectionChanged_ = function() {
    var projection = this.getProjection();
    if (projection) {
      this.transform_ = getTransformFromProjections(get("EPSG:4326"), projection);
      if (this.position_) {
        this.set(Property.POSITION, this.transform_(this.position_));
      }
    }
  };
  Geolocation2.prototype.handleTrackingChanged_ = function() {
    if ("geolocation" in navigator) {
      var tracking = this.getTracking();
      if (tracking && this.watchId_ === void 0) {
        this.watchId_ = navigator.geolocation.watchPosition(this.positionChange_.bind(this), this.positionError_.bind(this), this.getTrackingOptions());
      } else if (!tracking && this.watchId_ !== void 0) {
        navigator.geolocation.clearWatch(this.watchId_);
        this.watchId_ = void 0;
      }
    }
  };
  Geolocation2.prototype.positionChange_ = function(position) {
    var coords = position.coords;
    this.set(Property.ACCURACY, coords.accuracy);
    this.set(Property.ALTITUDE, coords.altitude === null ? void 0 : coords.altitude);
    this.set(Property.ALTITUDE_ACCURACY, coords.altitudeAccuracy === null ? void 0 : coords.altitudeAccuracy);
    this.set(Property.HEADING, coords.heading === null ? void 0 : toRadians(coords.heading));
    if (!this.position_) {
      this.position_ = [coords.longitude, coords.latitude];
    } else {
      this.position_[0] = coords.longitude;
      this.position_[1] = coords.latitude;
    }
    var projectedPosition = this.transform_(this.position_);
    this.set(Property.POSITION, projectedPosition);
    this.set(Property.SPEED, coords.speed === null ? void 0 : coords.speed);
    var geometry = circular(this.position_, coords.accuracy);
    geometry.applyTransform(this.transform_);
    this.set(Property.ACCURACY_GEOMETRY, geometry);
    this.changed();
  };
  Geolocation2.prototype.positionError_ = function(error) {
    this.dispatchEvent(new GeolocationError(error));
  };
  Geolocation2.prototype.getAccuracy = function() {
    return this.get(Property.ACCURACY);
  };
  Geolocation2.prototype.getAccuracyGeometry = function() {
    return this.get(Property.ACCURACY_GEOMETRY) || null;
  };
  Geolocation2.prototype.getAltitude = function() {
    return this.get(Property.ALTITUDE);
  };
  Geolocation2.prototype.getAltitudeAccuracy = function() {
    return this.get(Property.ALTITUDE_ACCURACY);
  };
  Geolocation2.prototype.getHeading = function() {
    return this.get(Property.HEADING);
  };
  Geolocation2.prototype.getPosition = function() {
    return this.get(Property.POSITION);
  };
  Geolocation2.prototype.getProjection = function() {
    return this.get(Property.PROJECTION);
  };
  Geolocation2.prototype.getSpeed = function() {
    return this.get(Property.SPEED);
  };
  Geolocation2.prototype.getTracking = function() {
    return this.get(Property.TRACKING);
  };
  Geolocation2.prototype.getTrackingOptions = function() {
    return this.get(Property.TRACKING_OPTIONS);
  };
  Geolocation2.prototype.setProjection = function(projection) {
    this.set(Property.PROJECTION, get(projection));
  };
  Geolocation2.prototype.setTracking = function(tracking) {
    this.set(Property.TRACKING, tracking);
  };
  Geolocation2.prototype.setTrackingOptions = function(options) {
    this.set(Property.TRACKING_OPTIONS, options);
  };
  return Geolocation2;
}(Object_default);
var Geolocation_default = Geolocation;

// node_modules/ol/render.js
function getVectorContext(event) {
  if (!(event.context instanceof CanvasRenderingContext2D)) {
    throw new Error("Only works for render events from Canvas 2D layers");
  }
  var canvasPixelRatio = event.inversePixelTransform[0];
  var frameState = event.frameState;
  var transform = multiply(event.inversePixelTransform.slice(), frameState.coordinateToPixelTransform);
  var squaredTolerance = getSquaredTolerance(frameState.viewState.resolution, canvasPixelRatio);
  var userTransform;
  var userProjection = getUserProjection();
  if (userProjection) {
    userTransform = getTransformFromProjections(userProjection, frameState.viewState.projection);
  }
  return new Immediate_default(event.context, canvasPixelRatio, frameState.extent, transform, frameState.viewState.rotation, squaredTolerance, userTransform);
}

// node_modules/ol/geom/flat/geodesic.js
function line(interpolate, transform, squaredTolerance) {
  var flatCoordinates = [];
  var geoA = interpolate(0);
  var geoB = interpolate(1);
  var a = transform(geoA);
  var b = transform(geoB);
  var geoStack = [geoB, geoA];
  var stack = [b, a];
  var fractionStack = [1, 0];
  var fractions = {};
  var maxIterations = 1e5;
  var geoM, m, fracA, fracB, fracM, key;
  while (--maxIterations > 0 && fractionStack.length > 0) {
    fracA = fractionStack.pop();
    geoA = geoStack.pop();
    a = stack.pop();
    key = fracA.toString();
    if (!(key in fractions)) {
      flatCoordinates.push(a[0], a[1]);
      fractions[key] = true;
    }
    fracB = fractionStack.pop();
    geoB = geoStack.pop();
    b = stack.pop();
    fracM = (fracA + fracB) / 2;
    geoM = interpolate(fracM);
    m = transform(geoM);
    if (squaredSegmentDistance(m[0], m[1], a[0], a[1], b[0], b[1]) < squaredTolerance) {
      flatCoordinates.push(b[0], b[1]);
      key = fracB.toString();
      fractions[key] = true;
    } else {
      fractionStack.push(fracB, fracM, fracM, fracA);
      stack.push(b, m, m, a);
      geoStack.push(geoB, geoM, geoM, geoA);
    }
  }
  return flatCoordinates;
}
function meridian(lon, lat1, lat2, projection, squaredTolerance) {
  var epsg4326Projection = get("EPSG:4326");
  return line(
    function(frac) {
      return [lon, lat1 + (lat2 - lat1) * frac];
    },
    getTransform(epsg4326Projection, projection),
    squaredTolerance
  );
}
function parallel(lat, lon1, lon2, projection, squaredTolerance) {
  var epsg4326Projection = get("EPSG:4326");
  return line(
    function(frac) {
      return [lon1 + (lon2 - lon1) * frac, lat];
    },
    getTransform(epsg4326Projection, projection),
    squaredTolerance
  );
}

// node_modules/ol/layer/Graticule.js
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DEFAULT_STROKE_STYLE = new Stroke_default({
  color: "rgba(0,0,0,0.2)"
});
var INTERVALS = [
  90,
  45,
  30,
  20,
  10,
  5,
  2,
  1,
  0.5,
  0.2,
  0.1,
  0.05,
  0.01,
  5e-3,
  2e-3,
  1e-3
];
var Graticule = function(_super) {
  __extends2(Graticule2, _super);
  function Graticule2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var baseOptions = assign({
      updateWhileAnimating: true,
      updateWhileInteracting: true,
      renderBuffer: 0
    }, options);
    delete baseOptions.maxLines;
    delete baseOptions.strokeStyle;
    delete baseOptions.targetSize;
    delete baseOptions.showLabels;
    delete baseOptions.lonLabelFormatter;
    delete baseOptions.latLabelFormatter;
    delete baseOptions.lonLabelPosition;
    delete baseOptions.latLabelPosition;
    delete baseOptions.lonLabelStyle;
    delete baseOptions.latLabelStyle;
    delete baseOptions.intervals;
    _this = _super.call(this, baseOptions) || this;
    _this.projection_ = null;
    _this.maxLat_ = Infinity;
    _this.maxLon_ = Infinity;
    _this.minLat_ = -Infinity;
    _this.minLon_ = -Infinity;
    _this.maxX_ = Infinity;
    _this.maxY_ = Infinity;
    _this.minX_ = -Infinity;
    _this.minY_ = -Infinity;
    _this.targetSize_ = options.targetSize !== void 0 ? options.targetSize : 100;
    _this.maxLines_ = options.maxLines !== void 0 ? options.maxLines : 100;
    _this.meridians_ = [];
    _this.parallels_ = [];
    _this.strokeStyle_ = options.strokeStyle !== void 0 ? options.strokeStyle : DEFAULT_STROKE_STYLE;
    _this.fromLonLatTransform_ = void 0;
    _this.toLonLatTransform_ = void 0;
    _this.projectionCenterLonLat_ = null;
    _this.bottomLeft_ = null;
    _this.bottomRight_ = null;
    _this.topLeft_ = null;
    _this.topRight_ = null;
    _this.meridiansLabels_ = null;
    _this.parallelsLabels_ = null;
    if (options.showLabels) {
      _this.lonLabelFormatter_ = options.lonLabelFormatter == void 0 ? degreesToStringHDMS.bind(_this, "EW") : options.lonLabelFormatter;
      _this.latLabelFormatter_ = options.latLabelFormatter == void 0 ? degreesToStringHDMS.bind(_this, "NS") : options.latLabelFormatter;
      _this.lonLabelPosition_ = options.lonLabelPosition == void 0 ? 0 : options.lonLabelPosition;
      _this.latLabelPosition_ = options.latLabelPosition == void 0 ? 1 : options.latLabelPosition;
      _this.lonLabelStyleBase_ = new Style_default({
        text: options.lonLabelStyle !== void 0 ? options.lonLabelStyle.clone() : new Text_default({
          font: "12px Calibri,sans-serif",
          textBaseline: "bottom",
          fill: new Fill_default({
            color: "rgba(0,0,0,1)"
          }),
          stroke: new Stroke_default({
            color: "rgba(255,255,255,1)",
            width: 3
          })
        })
      });
      _this.lonLabelStyle_ = function(feature) {
        var label = feature.get("graticule_label");
        this.lonLabelStyleBase_.getText().setText(label);
        return this.lonLabelStyleBase_;
      }.bind(_this);
      _this.latLabelStyleBase_ = new Style_default({
        text: options.latLabelStyle !== void 0 ? options.latLabelStyle.clone() : new Text_default({
          font: "12px Calibri,sans-serif",
          textAlign: "right",
          fill: new Fill_default({
            color: "rgba(0,0,0,1)"
          }),
          stroke: new Stroke_default({
            color: "rgba(255,255,255,1)",
            width: 3
          })
        })
      });
      _this.latLabelStyle_ = function(feature) {
        var label = feature.get("graticule_label");
        this.latLabelStyleBase_.getText().setText(label);
        return this.latLabelStyleBase_;
      }.bind(_this);
      _this.meridiansLabels_ = [];
      _this.parallelsLabels_ = [];
      _this.addEventListener(EventType_default2.POSTRENDER, _this.drawLabels_.bind(_this));
    }
    _this.intervals_ = options.intervals !== void 0 ? options.intervals : INTERVALS;
    _this.setSource(new Vector_default2({
      loader: _this.loaderFunction.bind(_this),
      strategy: _this.strategyFunction.bind(_this),
      features: new Collection_default(),
      overlaps: false,
      useSpatialIndex: false,
      wrapX: options.wrapX
    }));
    _this.featurePool_ = [];
    _this.lineStyle_ = new Style_default({
      stroke: _this.strokeStyle_
    });
    _this.loadedExtent_ = null;
    _this.renderedExtent_ = null;
    _this.renderedResolution_ = null;
    _this.setRenderOrder(null);
    return _this;
  }
  Graticule2.prototype.strategyFunction = function(extent, resolution) {
    var realWorldExtent = extent.slice();
    if (this.projection_ && this.getSource().getWrapX()) {
      wrapX(realWorldExtent, this.projection_);
    }
    if (this.loadedExtent_) {
      if (approximatelyEquals(this.loadedExtent_, realWorldExtent, resolution)) {
        realWorldExtent = this.loadedExtent_.slice();
      } else {
        this.getSource().removeLoadedExtent(this.loadedExtent_);
      }
    }
    return [realWorldExtent];
  };
  Graticule2.prototype.loaderFunction = function(extent, resolution, projection) {
    this.loadedExtent_ = extent;
    var source = this.getSource();
    var layerExtent = this.getExtent() || [
      -Infinity,
      -Infinity,
      Infinity,
      Infinity
    ];
    var renderExtent = getIntersection(layerExtent, extent);
    if (this.renderedExtent_ && equals2(this.renderedExtent_, renderExtent) && this.renderedResolution_ === resolution) {
      return;
    }
    this.renderedExtent_ = renderExtent;
    this.renderedResolution_ = resolution;
    if (isEmpty(renderExtent)) {
      return;
    }
    var center = getCenter(renderExtent);
    var squaredTolerance = resolution * resolution / 4;
    var updateProjectionInfo = !this.projection_ || !equivalent(this.projection_, projection);
    if (updateProjectionInfo) {
      this.updateProjectionInfo_(projection);
    }
    this.createGraticule_(renderExtent, center, resolution, squaredTolerance);
    var featureCount = this.meridians_.length + this.parallels_.length;
    if (this.meridiansLabels_) {
      featureCount += this.meridians_.length;
    }
    if (this.parallelsLabels_) {
      featureCount += this.parallels_.length;
    }
    var feature;
    while (featureCount > this.featurePool_.length) {
      feature = new Feature_default();
      this.featurePool_.push(feature);
    }
    var featuresColl = source.getFeaturesCollection();
    featuresColl.clear();
    var poolIndex = 0;
    var i, l;
    for (i = 0, l = this.meridians_.length; i < l; ++i) {
      feature = this.featurePool_[poolIndex++];
      feature.setGeometry(this.meridians_[i]);
      feature.setStyle(this.lineStyle_);
      featuresColl.push(feature);
    }
    for (i = 0, l = this.parallels_.length; i < l; ++i) {
      feature = this.featurePool_[poolIndex++];
      feature.setGeometry(this.parallels_[i]);
      feature.setStyle(this.lineStyle_);
      featuresColl.push(feature);
    }
  };
  Graticule2.prototype.addMeridian_ = function(lon, minLat, maxLat, squaredTolerance, extent, index) {
    var lineString = this.getMeridian_(lon, minLat, maxLat, squaredTolerance, index);
    if (intersects(lineString.getExtent(), extent)) {
      if (this.meridiansLabels_) {
        var text = this.lonLabelFormatter_(lon);
        if (index in this.meridiansLabels_) {
          this.meridiansLabels_[index].text = text;
        } else {
          this.meridiansLabels_[index] = {
            geom: new Point_default([]),
            text
          };
        }
      }
      this.meridians_[index++] = lineString;
    }
    return index;
  };
  Graticule2.prototype.addParallel_ = function(lat, minLon, maxLon, squaredTolerance, extent, index) {
    var lineString = this.getParallel_(lat, minLon, maxLon, squaredTolerance, index);
    if (intersects(lineString.getExtent(), extent)) {
      if (this.parallelsLabels_) {
        var text = this.latLabelFormatter_(lat);
        if (index in this.parallelsLabels_) {
          this.parallelsLabels_[index].text = text;
        } else {
          this.parallelsLabels_[index] = {
            geom: new Point_default([]),
            text
          };
        }
      }
      this.parallels_[index++] = lineString;
    }
    return index;
  };
  Graticule2.prototype.drawLabels_ = function(event) {
    var rotation = event.frameState.viewState.rotation;
    var resolution = event.frameState.viewState.resolution;
    var size = event.frameState.size;
    var extent = event.frameState.extent;
    var rotationCenter = getCenter(extent);
    var rotationExtent = extent;
    if (rotation) {
      var unrotatedWidth = size[0] * resolution;
      var unrotatedHeight = size[1] * resolution;
      rotationExtent = [
        rotationCenter[0] - unrotatedWidth / 2,
        rotationCenter[1] - unrotatedHeight / 2,
        rotationCenter[0] + unrotatedWidth / 2,
        rotationCenter[1] + unrotatedHeight / 2
      ];
    }
    var startWorld = 0;
    var endWorld = 0;
    var labelsAtStart = this.latLabelPosition_ < 0.5;
    var projectionExtent = this.projection_.getExtent();
    var worldWidth = getWidth(projectionExtent);
    if (this.getSource().getWrapX() && this.projection_.canWrapX() && !containsExtent(projectionExtent, extent)) {
      startWorld = Math.floor((extent[0] - projectionExtent[0]) / worldWidth);
      endWorld = Math.ceil((extent[2] - projectionExtent[2]) / worldWidth);
      var inverted = Math.abs(rotation) > Math.PI / 2;
      labelsAtStart = labelsAtStart !== inverted;
    }
    var vectorContext = getVectorContext(event);
    for (var world = startWorld; world <= endWorld; ++world) {
      var poolIndex = this.meridians_.length + this.parallels_.length;
      var feature = void 0, index = void 0, l = void 0, textPoint = void 0;
      if (this.meridiansLabels_) {
        for (index = 0, l = this.meridiansLabels_.length; index < l; ++index) {
          var lineString = this.meridians_[index];
          if (!rotation && world === 0) {
            textPoint = this.getMeridianPoint_(lineString, extent, index);
          } else {
            var clone2 = lineString.clone();
            clone2.translate(world * worldWidth, 0);
            clone2.rotate(-rotation, rotationCenter);
            textPoint = this.getMeridianPoint_(clone2, rotationExtent, index);
            textPoint.rotate(rotation, rotationCenter);
          }
          feature = this.featurePool_[poolIndex++];
          feature.setGeometry(textPoint);
          feature.set("graticule_label", this.meridiansLabels_[index].text);
          vectorContext.drawFeature(feature, this.lonLabelStyle_(feature));
        }
      }
      if (this.parallelsLabels_) {
        if (world === startWorld && labelsAtStart || world === endWorld && !labelsAtStart) {
          for (index = 0, l = this.parallels_.length; index < l; ++index) {
            var lineString = this.parallels_[index];
            if (!rotation && world === 0) {
              textPoint = this.getParallelPoint_(lineString, extent, index);
            } else {
              var clone2 = lineString.clone();
              clone2.translate(world * worldWidth, 0);
              clone2.rotate(-rotation, rotationCenter);
              textPoint = this.getParallelPoint_(clone2, rotationExtent, index);
              textPoint.rotate(rotation, rotationCenter);
            }
            feature = this.featurePool_[poolIndex++];
            feature.setGeometry(textPoint);
            feature.set("graticule_label", this.parallelsLabels_[index].text);
            vectorContext.drawFeature(feature, this.latLabelStyle_(feature));
          }
        }
      }
    }
  };
  Graticule2.prototype.createGraticule_ = function(extent, center, resolution, squaredTolerance) {
    var interval = this.getInterval_(resolution);
    if (interval == -1) {
      this.meridians_.length = 0;
      this.parallels_.length = 0;
      if (this.meridiansLabels_) {
        this.meridiansLabels_.length = 0;
      }
      if (this.parallelsLabels_) {
        this.parallelsLabels_.length = 0;
      }
      return;
    }
    var wrapX3 = false;
    var projectionExtent = this.projection_.getExtent();
    var worldWidth = getWidth(projectionExtent);
    if (this.getSource().getWrapX() && this.projection_.canWrapX() && !containsExtent(projectionExtent, extent)) {
      if (getWidth(extent) >= worldWidth) {
        extent[0] = projectionExtent[0];
        extent[2] = projectionExtent[2];
      } else {
        wrapX3 = true;
      }
    }
    var validCenterP = [
      clamp(center[0], this.minX_, this.maxX_),
      clamp(center[1], this.minY_, this.maxY_)
    ];
    var centerLonLat = this.toLonLatTransform_(validCenterP);
    if (isNaN(centerLonLat[1])) {
      centerLonLat[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;
    }
    var centerLon = clamp(centerLonLat[0], this.minLon_, this.maxLon_);
    var centerLat = clamp(centerLonLat[1], this.minLat_, this.maxLat_);
    var maxLines = this.maxLines_;
    var cnt, idx, lat, lon;
    var validExtentP = extent;
    if (!wrapX3) {
      validExtentP = [
        clamp(extent[0], this.minX_, this.maxX_),
        clamp(extent[1], this.minY_, this.maxY_),
        clamp(extent[2], this.minX_, this.maxX_),
        clamp(extent[3], this.minY_, this.maxY_)
      ];
    }
    var validExtent = applyTransform(validExtentP, this.toLonLatTransform_, void 0, 8);
    var maxLat = validExtent[3];
    var maxLon = validExtent[2];
    var minLat = validExtent[1];
    var minLon = validExtent[0];
    if (!wrapX3) {
      if (containsCoordinate(validExtentP, this.bottomLeft_)) {
        minLon = this.minLon_;
        minLat = this.minLat_;
      }
      if (containsCoordinate(validExtentP, this.bottomRight_)) {
        maxLon = this.maxLon_;
        minLat = this.minLat_;
      }
      if (containsCoordinate(validExtentP, this.topLeft_)) {
        minLon = this.minLon_;
        maxLat = this.maxLat_;
      }
      if (containsCoordinate(validExtentP, this.topRight_)) {
        maxLon = this.maxLon_;
        maxLat = this.maxLat_;
      }
      maxLat = clamp(maxLat, centerLat, this.maxLat_);
      maxLon = clamp(maxLon, centerLon, this.maxLon_);
      minLat = clamp(minLat, this.minLat_, centerLat);
      minLon = clamp(minLon, this.minLon_, centerLon);
    }
    centerLon = Math.floor(centerLon / interval) * interval;
    lon = clamp(centerLon, this.minLon_, this.maxLon_);
    idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);
    cnt = 0;
    if (wrapX3) {
      while ((lon -= interval) >= minLon && cnt++ < maxLines) {
        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
      }
    } else {
      while (lon != this.minLon_ && cnt++ < maxLines) {
        lon = Math.max(lon - interval, this.minLon_);
        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
      }
    }
    lon = clamp(centerLon, this.minLon_, this.maxLon_);
    cnt = 0;
    if (wrapX3) {
      while ((lon += interval) <= maxLon && cnt++ < maxLines) {
        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
      }
    } else {
      while (lon != this.maxLon_ && cnt++ < maxLines) {
        lon = Math.min(lon + interval, this.maxLon_);
        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
      }
    }
    this.meridians_.length = idx;
    if (this.meridiansLabels_) {
      this.meridiansLabels_.length = idx;
    }
    centerLat = Math.floor(centerLat / interval) * interval;
    lat = clamp(centerLat, this.minLat_, this.maxLat_);
    idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);
    cnt = 0;
    while (lat != this.minLat_ && cnt++ < maxLines) {
      lat = Math.max(lat - interval, this.minLat_);
      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);
    }
    lat = clamp(centerLat, this.minLat_, this.maxLat_);
    cnt = 0;
    while (lat != this.maxLat_ && cnt++ < maxLines) {
      lat = Math.min(lat + interval, this.maxLat_);
      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);
    }
    this.parallels_.length = idx;
    if (this.parallelsLabels_) {
      this.parallelsLabels_.length = idx;
    }
  };
  Graticule2.prototype.getInterval_ = function(resolution) {
    var centerLon = this.projectionCenterLonLat_[0];
    var centerLat = this.projectionCenterLonLat_[1];
    var interval = -1;
    var target = Math.pow(this.targetSize_ * resolution, 2);
    var p1 = [];
    var p2 = [];
    for (var i = 0, ii = this.intervals_.length; i < ii; ++i) {
      var delta = clamp(this.intervals_[i] / 2, 0, 90);
      var clampedLat = clamp(centerLat, -90 + delta, 90 - delta);
      p1[0] = centerLon - delta;
      p1[1] = clampedLat - delta;
      p2[0] = centerLon + delta;
      p2[1] = clampedLat + delta;
      this.fromLonLatTransform_(p1, p1);
      this.fromLonLatTransform_(p2, p2);
      var dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);
      if (dist <= target) {
        break;
      }
      interval = this.intervals_[i];
    }
    return interval;
  };
  Graticule2.prototype.getMeridian_ = function(lon, minLat, maxLat, squaredTolerance, index) {
    var flatCoordinates = meridian(lon, minLat, maxLat, this.projection_, squaredTolerance);
    var lineString = this.meridians_[index];
    if (!lineString) {
      lineString = new LineString_default(flatCoordinates, GeometryLayout_default.XY);
      this.meridians_[index] = lineString;
    } else {
      lineString.setFlatCoordinates(GeometryLayout_default.XY, flatCoordinates);
      lineString.changed();
    }
    return lineString;
  };
  Graticule2.prototype.getMeridianPoint_ = function(lineString, extent, index) {
    var flatCoordinates = lineString.getFlatCoordinates();
    var bottom = 1;
    var top = flatCoordinates.length - 1;
    if (flatCoordinates[bottom] > flatCoordinates[top]) {
      bottom = top;
      top = 1;
    }
    var clampedBottom = Math.max(extent[1], flatCoordinates[bottom]);
    var clampedTop = Math.min(extent[3], flatCoordinates[top]);
    var lat = clamp(extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_, clampedBottom, clampedTop);
    var coordinate0 = flatCoordinates[bottom - 1] + (flatCoordinates[top - 1] - flatCoordinates[bottom - 1]) * (lat - flatCoordinates[bottom]) / (flatCoordinates[top] - flatCoordinates[bottom]);
    var coordinate = [coordinate0, lat];
    var point = this.meridiansLabels_[index].geom;
    point.setCoordinates(coordinate);
    return point;
  };
  Graticule2.prototype.getMeridians = function() {
    return this.meridians_;
  };
  Graticule2.prototype.getParallel_ = function(lat, minLon, maxLon, squaredTolerance, index) {
    var flatCoordinates = parallel(lat, minLon, maxLon, this.projection_, squaredTolerance);
    var lineString = this.parallels_[index];
    if (!lineString) {
      lineString = new LineString_default(flatCoordinates, GeometryLayout_default.XY);
    } else {
      lineString.setFlatCoordinates(GeometryLayout_default.XY, flatCoordinates);
      lineString.changed();
    }
    return lineString;
  };
  Graticule2.prototype.getParallelPoint_ = function(lineString, extent, index) {
    var flatCoordinates = lineString.getFlatCoordinates();
    var left = 0;
    var right = flatCoordinates.length - 2;
    if (flatCoordinates[left] > flatCoordinates[right]) {
      left = right;
      right = 0;
    }
    var clampedLeft = Math.max(extent[0], flatCoordinates[left]);
    var clampedRight = Math.min(extent[2], flatCoordinates[right]);
    var lon = clamp(extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_, clampedLeft, clampedRight);
    var coordinate1 = flatCoordinates[left + 1] + (flatCoordinates[right + 1] - flatCoordinates[left + 1]) * (lon - flatCoordinates[left]) / (flatCoordinates[right] - flatCoordinates[left]);
    var coordinate = [lon, coordinate1];
    var point = this.parallelsLabels_[index].geom;
    point.setCoordinates(coordinate);
    return point;
  };
  Graticule2.prototype.getParallels = function() {
    return this.parallels_;
  };
  Graticule2.prototype.updateProjectionInfo_ = function(projection) {
    var epsg4326Projection = get("EPSG:4326");
    var worldExtent = projection.getWorldExtent();
    this.maxLat_ = worldExtent[3];
    this.maxLon_ = worldExtent[2];
    this.minLat_ = worldExtent[1];
    this.minLon_ = worldExtent[0];
    var toLonLatTransform = getTransform(projection, epsg4326Projection);
    if (this.minLon_ < this.maxLon_) {
      this.toLonLatTransform_ = toLonLatTransform;
    } else {
      var split_1 = this.minLon_ + this.maxLon_ / 2;
      this.maxLon_ += 360;
      this.toLonLatTransform_ = function(coordinates, opt_output, opt_dimension) {
        var dimension = opt_dimension || 2;
        var lonLatCoordinates = toLonLatTransform(coordinates, opt_output, dimension);
        for (var i = 0, l = lonLatCoordinates.length; i < l; i += dimension) {
          if (lonLatCoordinates[i] < split_1) {
            lonLatCoordinates[i] += 360;
          }
        }
        return lonLatCoordinates;
      };
    }
    this.fromLonLatTransform_ = getTransform(epsg4326Projection, projection);
    var worldExtentP = applyTransform([this.minLon_, this.minLat_, this.maxLon_, this.maxLat_], this.fromLonLatTransform_, void 0, 8);
    this.minX_ = worldExtentP[0];
    this.maxX_ = worldExtentP[2];
    this.minY_ = worldExtentP[1];
    this.maxY_ = worldExtentP[3];
    this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]);
    this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]);
    this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]);
    this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]);
    this.projectionCenterLonLat_ = this.toLonLatTransform_(getCenter(projection.getExtent()));
    if (isNaN(this.projectionCenterLonLat_[1])) {
      this.projectionCenterLonLat_[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;
    }
    this.projection_ = projection;
  };
  return Graticule2;
}(Vector_default);
var Graticule_default = Graticule;

// node_modules/ol/Kinetic.js
var Kinetic = function() {
  function Kinetic2(decay, minVelocity, delay) {
    this.decay_ = decay;
    this.minVelocity_ = minVelocity;
    this.delay_ = delay;
    this.points_ = [];
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }
  Kinetic2.prototype.begin = function() {
    this.points_.length = 0;
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  };
  Kinetic2.prototype.update = function(x, y) {
    this.points_.push(x, y, Date.now());
  };
  Kinetic2.prototype.end = function() {
    if (this.points_.length < 6) {
      return false;
    }
    var delay = Date.now() - this.delay_;
    var lastIndex = this.points_.length - 3;
    if (this.points_[lastIndex + 2] < delay) {
      return false;
    }
    var firstIndex = lastIndex - 3;
    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
      firstIndex -= 3;
    }
    var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
    if (duration < 1e3 / 60) {
      return false;
    }
    var dx = this.points_[lastIndex] - this.points_[firstIndex];
    var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
    this.angle_ = Math.atan2(dy, dx);
    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
    return this.initialVelocity_ > this.minVelocity_;
  };
  Kinetic2.prototype.getDistance = function() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  };
  Kinetic2.prototype.getAngle = function() {
    return this.angle_;
  };
  return Kinetic2;
}();
var Kinetic_default = Kinetic;

// node_modules/ol/renderer/Map.js
var __extends3 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var MapRenderer = function(_super) {
  __extends3(MapRenderer2, _super);
  function MapRenderer2(map) {
    var _this = _super.call(this) || this;
    _this.map_ = map;
    return _this;
  }
  MapRenderer2.prototype.dispatchRenderEvent = function(type, frameState) {
    abstract();
  };
  MapRenderer2.prototype.calculateMatrices2D = function(frameState) {
    var viewState = frameState.viewState;
    var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
    compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
  };
  MapRenderer2.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
    var result;
    var viewState = frameState.viewState;
    function forEachFeatureAtCoordinate(managed, feature, layer2, geometry) {
      return callback.call(thisArg, feature, managed ? layer2 : null, geometry);
    }
    var projection = viewState.projection;
    var translatedCoordinate = wrapX2(coordinate.slice(), projection);
    var offsets = [[0, 0]];
    if (projection.canWrapX() && checkWrapped) {
      var projectionExtent = projection.getExtent();
      var worldWidth = getWidth(projectionExtent);
      offsets.push([-worldWidth, 0], [worldWidth, 0]);
    }
    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;
    var matches = [];
    var tmpCoord = [];
    for (var i = 0; i < offsets.length; i++) {
      for (var j = numLayers - 1; j >= 0; --j) {
        var layerState = layerStates[j];
        var layer = layerState.layer;
        if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
          var layerRenderer = layer.getRenderer();
          var source = layer.getSource();
          if (layerRenderer && source) {
            var coordinates = source.getWrapX() ? translatedCoordinate : coordinate;
            var callback_1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);
            tmpCoord[0] = coordinates[0] + offsets[i][0];
            tmpCoord[1] = coordinates[1] + offsets[i][1];
            result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback_1, matches);
          }
          if (result) {
            return result;
          }
        }
      }
    }
    if (matches.length === 0) {
      return void 0;
    }
    var order = 1 / matches.length;
    matches.forEach(function(m, i2) {
      return m.distanceSq += i2 * order;
    });
    matches.sort(function(a, b) {
      return a.distanceSq - b.distanceSq;
    });
    matches.some(function(m) {
      return result = m.callback(m.feature, m.layer, m.geometry);
    });
    return result;
  };
  MapRenderer2.prototype.forEachLayerAtPixel = function(pixel, frameState, hitTolerance, callback, layerFilter) {
    return abstract();
  };
  MapRenderer2.prototype.hasFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, TRUE, this, layerFilter, thisArg);
    return hasFeature !== void 0;
  };
  MapRenderer2.prototype.getMap = function() {
    return this.map_;
  };
  MapRenderer2.prototype.renderFrame = function(frameState) {
    abstract();
  };
  MapRenderer2.prototype.scheduleExpireIconCache = function(frameState) {
    if (shared.canExpireCache()) {
      frameState.postRenderFunctions.push(expireIconCache);
    }
  };
  return MapRenderer2;
}(Disposable_default);
function expireIconCache(map, frameState) {
  shared.expire();
}
var Map_default = MapRenderer;

// node_modules/ol/renderer/Composite.js
var __extends4 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CompositeMapRenderer = function(_super) {
  __extends4(CompositeMapRenderer2, _super);
  function CompositeMapRenderer2(map) {
    var _this = _super.call(this, map) || this;
    _this.fontChangeListenerKey_ = listen(checkedFonts, ObjectEventType_default.PROPERTYCHANGE, map.redrawText.bind(map));
    _this.element_ = document.createElement("div");
    var style = _this.element_.style;
    style.position = "absolute";
    style.width = "100%";
    style.height = "100%";
    style.zIndex = "0";
    _this.element_.className = CLASS_UNSELECTABLE + " ol-layers";
    var container = map.getViewport();
    container.insertBefore(_this.element_, container.firstChild || null);
    _this.children_ = [];
    _this.renderedVisible_ = true;
    return _this;
  }
  CompositeMapRenderer2.prototype.dispatchRenderEvent = function(type, frameState) {
    var map = this.getMap();
    if (map.hasListener(type)) {
      var event_1 = new Event_default2(type, void 0, frameState);
      map.dispatchEvent(event_1);
    }
  };
  CompositeMapRenderer2.prototype.disposeInternal = function() {
    unlistenByKey(this.fontChangeListenerKey_);
    this.element_.parentNode.removeChild(this.element_);
    _super.prototype.disposeInternal.call(this);
  };
  CompositeMapRenderer2.prototype.renderFrame = function(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element_.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    this.calculateMatrices2D(frameState);
    this.dispatchRenderEvent(EventType_default2.PRECOMPOSE, frameState);
    var layerStatesArray = frameState.layerStatesArray.sort(function(a, b) {
      return a.zIndex - b.zIndex;
    });
    var viewState = frameState.viewState;
    this.children_.length = 0;
    var declutterLayers = [];
    var previousElement = null;
    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      var layerState = layerStatesArray[i];
      frameState.layerIndex = i;
      var layer = layerState.layer;
      var sourceState = layer.getSourceState();
      if (!inView(layerState, viewState) || sourceState != "ready" && sourceState != "undefined") {
        layer.unrender();
        continue;
      }
      var element = layer.render(frameState, previousElement);
      if (!element) {
        continue;
      }
      if (element !== previousElement) {
        this.children_.push(element);
        previousElement = element;
      }
      if ("getDeclutter" in layer) {
        declutterLayers.push(
          layer
        );
      }
    }
    for (var i = declutterLayers.length - 1; i >= 0; --i) {
      declutterLayers[i].renderDeclutter(frameState);
    }
    replaceChildren(this.element_, this.children_);
    this.dispatchRenderEvent(EventType_default2.POSTCOMPOSE, frameState);
    if (!this.renderedVisible_) {
      this.element_.style.display = "";
      this.renderedVisible_ = true;
    }
    this.scheduleExpireIconCache(frameState);
  };
  CompositeMapRenderer2.prototype.forEachLayerAtPixel = function(pixel, frameState, hitTolerance, callback, layerFilter) {
    var viewState = frameState.viewState;
    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;
    for (var i = numLayers - 1; i >= 0; --i) {
      var layerState = layerStates[i];
      var layer = layerState.layer;
      if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter(layer)) {
        var layerRenderer = layer.getRenderer();
        var data = layerRenderer.getDataAtPixel(pixel, frameState, hitTolerance);
        if (data) {
          var result = callback(layer, data);
          if (result) {
            return result;
          }
        }
      }
    }
    return void 0;
  };
  return CompositeMapRenderer2;
}(Map_default);
var Composite_default = CompositeMapRenderer;

// node_modules/ol/pointer/EventType.js
var EventType_default3 = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};

// node_modules/ol/MapBrowserEventHandler.js
var __extends5 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var MapBrowserEventHandler = function(_super) {
  __extends5(MapBrowserEventHandler2, _super);
  function MapBrowserEventHandler2(map, moveTolerance) {
    var _this = _super.call(this, map) || this;
    _this.map_ = map;
    _this.clickTimeoutId_;
    _this.emulateClicks_ = false;
    _this.dragging_ = false;
    _this.dragListenerKeys_ = [];
    _this.moveTolerance_ = moveTolerance === void 0 ? 1 : moveTolerance;
    _this.down_ = null;
    var element = _this.map_.getViewport();
    _this.activePointers_ = [];
    _this.trackedTouches_ = {};
    _this.element_ = element;
    _this.pointerdownListenerKey_ = listen(element, EventType_default3.POINTERDOWN, _this.handlePointerDown_, _this);
    _this.originalPointerMoveEvent_;
    _this.relayedListenerKey_ = listen(element, EventType_default3.POINTERMOVE, _this.relayMoveEvent_, _this);
    _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);
    _this.element_.addEventListener(EventType_default.TOUCHMOVE, _this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);
    return _this;
  }
  MapBrowserEventHandler2.prototype.emulateClick_ = function(pointerEvent) {
    var newEvent = new MapBrowserEvent_default(MapBrowserEventType_default.CLICK, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);
    if (this.clickTimeoutId_ !== void 0) {
      clearTimeout(this.clickTimeoutId_);
      this.clickTimeoutId_ = void 0;
      newEvent = new MapBrowserEvent_default(MapBrowserEventType_default.DBLCLICK, this.map_, pointerEvent);
      this.dispatchEvent(newEvent);
    } else {
      this.clickTimeoutId_ = setTimeout(
        function() {
          this.clickTimeoutId_ = void 0;
          var newEvent2 = new MapBrowserEvent_default(MapBrowserEventType_default.SINGLECLICK, this.map_, pointerEvent);
          this.dispatchEvent(newEvent2);
        }.bind(this),
        250
      );
    }
  };
  MapBrowserEventHandler2.prototype.updateActivePointers_ = function(pointerEvent) {
    var event = pointerEvent;
    var id = event.pointerId;
    if (event.type == MapBrowserEventType_default.POINTERUP || event.type == MapBrowserEventType_default.POINTERCANCEL) {
      delete this.trackedTouches_[id];
      for (var pointerId in this.trackedTouches_) {
        if (this.trackedTouches_[pointerId].target !== event.target) {
          delete this.trackedTouches_[pointerId];
          break;
        }
      }
    } else if (event.type == MapBrowserEventType_default.POINTERDOWN || event.type == MapBrowserEventType_default.POINTERMOVE) {
      this.trackedTouches_[id] = event;
    }
    this.activePointers_ = getValues(this.trackedTouches_);
  };
  MapBrowserEventHandler2.prototype.handlePointerUp_ = function(pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    var newEvent = new MapBrowserEvent_default(MapBrowserEventType_default.POINTERUP, this.map_, pointerEvent, void 0, void 0, this.activePointers_);
    this.dispatchEvent(newEvent);
    if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
      this.emulateClick_(this.down_);
    }
    if (this.activePointers_.length === 0) {
      this.dragListenerKeys_.forEach(unlistenByKey);
      this.dragListenerKeys_.length = 0;
      this.dragging_ = false;
      this.down_ = null;
    }
  };
  MapBrowserEventHandler2.prototype.isMouseActionButton_ = function(pointerEvent) {
    return pointerEvent.button === 0;
  };
  MapBrowserEventHandler2.prototype.handlePointerDown_ = function(pointerEvent) {
    this.emulateClicks_ = this.activePointers_.length === 0;
    this.updateActivePointers_(pointerEvent);
    var newEvent = new MapBrowserEvent_default(MapBrowserEventType_default.POINTERDOWN, this.map_, pointerEvent, void 0, void 0, this.activePointers_);
    this.dispatchEvent(newEvent);
    this.down_ = {};
    for (var property in pointerEvent) {
      var value = pointerEvent[property];
      this.down_[property] = typeof value === "function" ? VOID : value;
    }
    if (this.dragListenerKeys_.length === 0) {
      var doc = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        listen(doc, MapBrowserEventType_default.POINTERMOVE, this.handlePointerMove_, this),
        listen(doc, MapBrowserEventType_default.POINTERUP, this.handlePointerUp_, this),
        listen(this.element_, MapBrowserEventType_default.POINTERCANCEL, this.handlePointerUp_, this)
      );
      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
        this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType_default.POINTERUP, this.handlePointerUp_, this));
      }
    }
  };
  MapBrowserEventHandler2.prototype.handlePointerMove_ = function(pointerEvent) {
    if (this.isMoving_(pointerEvent)) {
      this.updateActivePointers_(pointerEvent);
      this.dragging_ = true;
      var newEvent = new MapBrowserEvent_default(MapBrowserEventType_default.POINTERDRAG, this.map_, pointerEvent, this.dragging_, void 0, this.activePointers_);
      this.dispatchEvent(newEvent);
    }
  };
  MapBrowserEventHandler2.prototype.relayMoveEvent_ = function(pointerEvent) {
    this.originalPointerMoveEvent_ = pointerEvent;
    var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
    this.dispatchEvent(new MapBrowserEvent_default(MapBrowserEventType_default.POINTERMOVE, this.map_, pointerEvent, dragging));
  };
  MapBrowserEventHandler2.prototype.handleTouchMove_ = function(event) {
    var originalEvent = this.originalPointerMoveEvent_;
    if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== "boolean" || event.cancelable === true)) {
      event.preventDefault();
    }
  };
  MapBrowserEventHandler2.prototype.isMoving_ = function(pointerEvent) {
    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
  };
  MapBrowserEventHandler2.prototype.disposeInternal = function() {
    if (this.relayedListenerKey_) {
      unlistenByKey(this.relayedListenerKey_);
      this.relayedListenerKey_ = null;
    }
    this.element_.removeEventListener(EventType_default.TOUCHMOVE, this.boundHandleTouchMove_);
    if (this.pointerdownListenerKey_) {
      unlistenByKey(this.pointerdownListenerKey_);
      this.pointerdownListenerKey_ = null;
    }
    this.dragListenerKeys_.forEach(unlistenByKey);
    this.dragListenerKeys_.length = 0;
    this.element_ = null;
    _super.prototype.disposeInternal.call(this);
  };
  return MapBrowserEventHandler2;
}(Target_default);
var MapBrowserEventHandler_default = MapBrowserEventHandler;

// node_modules/ol/MapEventType.js
var MapEventType_default = {
  POSTRENDER: "postrender",
  MOVESTART: "movestart",
  MOVEEND: "moveend",
  LOADSTART: "loadstart",
  LOADEND: "loadend"
};

// node_modules/ol/MapProperty.js
var MapProperty_default = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
};

// node_modules/ol/structs/PriorityQueue.js
var DROP = Infinity;
var PriorityQueue = function() {
  function PriorityQueue2(priorityFunction, keyFunction) {
    this.priorityFunction_ = priorityFunction;
    this.keyFunction_ = keyFunction;
    this.elements_ = [];
    this.priorities_ = [];
    this.queuedElements_ = {};
  }
  PriorityQueue2.prototype.clear = function() {
    this.elements_.length = 0;
    this.priorities_.length = 0;
    clear(this.queuedElements_);
  };
  PriorityQueue2.prototype.dequeue = function() {
    var elements = this.elements_;
    var priorities = this.priorities_;
    var element = elements[0];
    if (elements.length == 1) {
      elements.length = 0;
      priorities.length = 0;
    } else {
      elements[0] = elements.pop();
      priorities[0] = priorities.pop();
      this.siftUp_(0);
    }
    var elementKey = this.keyFunction_(element);
    delete this.queuedElements_[elementKey];
    return element;
  };
  PriorityQueue2.prototype.enqueue = function(element) {
    assert(!(this.keyFunction_(element) in this.queuedElements_), 31);
    var priority = this.priorityFunction_(element);
    if (priority != DROP) {
      this.elements_.push(element);
      this.priorities_.push(priority);
      this.queuedElements_[this.keyFunction_(element)] = true;
      this.siftDown_(0, this.elements_.length - 1);
      return true;
    }
    return false;
  };
  PriorityQueue2.prototype.getCount = function() {
    return this.elements_.length;
  };
  PriorityQueue2.prototype.getLeftChildIndex_ = function(index) {
    return index * 2 + 1;
  };
  PriorityQueue2.prototype.getRightChildIndex_ = function(index) {
    return index * 2 + 2;
  };
  PriorityQueue2.prototype.getParentIndex_ = function(index) {
    return index - 1 >> 1;
  };
  PriorityQueue2.prototype.heapify_ = function() {
    var i;
    for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
      this.siftUp_(i);
    }
  };
  PriorityQueue2.prototype.isEmpty = function() {
    return this.elements_.length === 0;
  };
  PriorityQueue2.prototype.isKeyQueued = function(key) {
    return key in this.queuedElements_;
  };
  PriorityQueue2.prototype.isQueued = function(element) {
    return this.isKeyQueued(this.keyFunction_(element));
  };
  PriorityQueue2.prototype.siftUp_ = function(index) {
    var elements = this.elements_;
    var priorities = this.priorities_;
    var count = elements.length;
    var element = elements[index];
    var priority = priorities[index];
    var startIndex = index;
    while (index < count >> 1) {
      var lIndex = this.getLeftChildIndex_(index);
      var rIndex = this.getRightChildIndex_(index);
      var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
      elements[index] = elements[smallerChildIndex];
      priorities[index] = priorities[smallerChildIndex];
      index = smallerChildIndex;
    }
    elements[index] = element;
    priorities[index] = priority;
    this.siftDown_(startIndex, index);
  };
  PriorityQueue2.prototype.siftDown_ = function(startIndex, index) {
    var elements = this.elements_;
    var priorities = this.priorities_;
    var element = elements[index];
    var priority = priorities[index];
    while (index > startIndex) {
      var parentIndex = this.getParentIndex_(index);
      if (priorities[parentIndex] > priority) {
        elements[index] = elements[parentIndex];
        priorities[index] = priorities[parentIndex];
        index = parentIndex;
      } else {
        break;
      }
    }
    elements[index] = element;
    priorities[index] = priority;
  };
  PriorityQueue2.prototype.reprioritize = function() {
    var priorityFunction = this.priorityFunction_;
    var elements = this.elements_;
    var priorities = this.priorities_;
    var index = 0;
    var n = elements.length;
    var element, i, priority;
    for (i = 0; i < n; ++i) {
      element = elements[i];
      priority = priorityFunction(element);
      if (priority == DROP) {
        delete this.queuedElements_[this.keyFunction_(element)];
      } else {
        priorities[index] = priority;
        elements[index++] = element;
      }
    }
    elements.length = index;
    priorities.length = index;
    this.heapify_();
  };
  return PriorityQueue2;
}();
var PriorityQueue_default = PriorityQueue;

// node_modules/ol/TileQueue.js
var __extends6 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TileQueue = function(_super) {
  __extends6(TileQueue2, _super);
  function TileQueue2(tilePriorityFunction, tileChangeCallback) {
    var _this = _super.call(
      this,
      function(element) {
        return tilePriorityFunction.apply(null, element);
      },
      function(element) {
        return element[0].getKey();
      }
    ) || this;
    _this.boundHandleTileChange_ = _this.handleTileChange.bind(_this);
    _this.tileChangeCallback_ = tileChangeCallback;
    _this.tilesLoading_ = 0;
    _this.tilesLoadingKeys_ = {};
    return _this;
  }
  TileQueue2.prototype.enqueue = function(element) {
    var added = _super.prototype.enqueue.call(this, element);
    if (added) {
      var tile = element[0];
      tile.addEventListener(EventType_default.CHANGE, this.boundHandleTileChange_);
    }
    return added;
  };
  TileQueue2.prototype.getTilesLoading = function() {
    return this.tilesLoading_;
  };
  TileQueue2.prototype.handleTileChange = function(event) {
    var tile = event.target;
    var state = tile.getState();
    if (state === TileState_default.LOADED || state === TileState_default.ERROR || state === TileState_default.EMPTY) {
      tile.removeEventListener(EventType_default.CHANGE, this.boundHandleTileChange_);
      var tileKey = tile.getKey();
      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }
      this.tileChangeCallback_();
    }
  };
  TileQueue2.prototype.loadMoreTiles = function(maxTotalLoading, maxNewLoads) {
    var newLoads = 0;
    var state, tile, tileKey;
    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
      tile = this.dequeue()[0];
      tileKey = tile.getKey();
      state = tile.getState();
      if (state === TileState_default.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile.load();
      }
    }
  };
  return TileQueue2;
}(PriorityQueue_default);
var TileQueue_default = TileQueue;
function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return DROP;
  }
  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return DROP;
  }
  var center = frameState.viewState.center;
  var deltaX = tileCenter[0] - center[0];
  var deltaY = tileCenter[1] - center[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}

// node_modules/ol/ViewProperty.js
var ViewProperty_default = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
};

// node_modules/ol/centerconstraint.js
function createExtent(extent, onlyCenter, smooth) {
  return function(center, resolution, size, opt_isMoving, opt_centerShift) {
    if (!center) {
      return void 0;
    }
    if (!resolution && !onlyCenter) {
      return center;
    }
    var viewWidth = onlyCenter ? 0 : size[0] * resolution;
    var viewHeight = onlyCenter ? 0 : size[1] * resolution;
    var shiftX = opt_centerShift ? opt_centerShift[0] : 0;
    var shiftY = opt_centerShift ? opt_centerShift[1] : 0;
    var minX = extent[0] + viewWidth / 2 + shiftX;
    var maxX = extent[2] - viewWidth / 2 + shiftX;
    var minY = extent[1] + viewHeight / 2 + shiftY;
    var maxY = extent[3] - viewHeight / 2 + shiftY;
    if (minX > maxX) {
      minX = (maxX + minX) / 2;
      maxX = minX;
    }
    if (minY > maxY) {
      minY = (maxY + minY) / 2;
      maxY = minY;
    }
    var x = clamp(center[0], minX, maxX);
    var y = clamp(center[1], minY, maxY);
    if (opt_isMoving && smooth && resolution) {
      var ratio = 30 * resolution;
      x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
      y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
    }
    return [x, y];
  };
}
function none(center) {
  return center;
}

// node_modules/ol/resolutionconstraint.js
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  var xResolution = getWidth(maxExtent) / viewportSize[0];
  var yResolution = getHeight(maxExtent) / viewportSize[1];
  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }
  return Math.min(resolution, Math.min(xResolution, yResolution));
}
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  var result = Math.min(resolution, maxResolution);
  var ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }
  return clamp(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {
  return function(resolution, direction, size, opt_isMoving) {
    if (resolution !== void 0) {
      var maxResolution = resolutions[0];
      var minResolution = resolutions[resolutions.length - 1];
      var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
      if (opt_isMoving) {
        var smooth = opt_smooth !== void 0 ? opt_smooth : true;
        if (!smooth) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
      }
      var capped = Math.min(cappedMaxRes, resolution);
      var z = Math.floor(linearFindNearest(resolutions, capped, direction));
      if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
        return resolutions[z + 1];
      }
      return resolutions[z];
    } else {
      return void 0;
    }
  };
}
function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
  return function(resolution, direction, size, opt_isMoving) {
    if (resolution !== void 0) {
      var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
      var minResolution = opt_minResolution !== void 0 ? opt_minResolution : 0;
      if (opt_isMoving) {
        var smooth = opt_smooth !== void 0 ? opt_smooth : true;
        if (!smooth) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
      }
      var tolerance = 1e-9;
      var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
      var offset = -direction * (0.5 - tolerance) + 0.5;
      var capped = Math.min(cappedMaxRes, resolution);
      var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
      var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
      var newResolution = maxResolution / Math.pow(power, zoomLevel);
      return clamp(newResolution, minResolution, cappedMaxRes);
    } else {
      return void 0;
    }
  };
}
function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
  return function(resolution, direction, size, opt_isMoving) {
    if (resolution !== void 0) {
      var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
      var smooth = opt_smooth !== void 0 ? opt_smooth : true;
      if (!smooth || !opt_isMoving) {
        return clamp(resolution, minResolution, cappedMaxRes);
      }
      return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
    } else {
      return void 0;
    }
  };
}

// node_modules/ol/rotationconstraint.js
function disable(rotation) {
  if (rotation !== void 0) {
    return 0;
  } else {
    return void 0;
  }
}
function none2(rotation) {
  if (rotation !== void 0) {
    return rotation;
  } else {
    return void 0;
  }
}
function createSnapToN(n) {
  var theta = 2 * Math.PI / n;
  return function(rotation, opt_isMoving) {
    if (opt_isMoving) {
      return rotation;
    }
    if (rotation !== void 0) {
      rotation = Math.floor(rotation / theta + 0.5) * theta;
      return rotation;
    } else {
      return void 0;
    }
  };
}
function createSnapToZero(opt_tolerance) {
  var tolerance = opt_tolerance || toRadians(5);
  return function(rotation, opt_isMoving) {
    if (opt_isMoving) {
      return rotation;
    }
    if (rotation !== void 0) {
      if (Math.abs(rotation) <= tolerance) {
        return 0;
      } else {
        return rotation;
      }
    } else {
      return void 0;
    }
  };
}

// node_modules/ol/View.js
var __extends7 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DEFAULT_MIN_ZOOM = 0;
var View = function(_super) {
  __extends7(View2, _super);
  function View2(opt_options) {
    var _this = _super.call(this) || this;
    _this.on;
    _this.once;
    _this.un;
    var options = assign({}, opt_options);
    _this.hints_ = [0, 0];
    _this.animations_ = [];
    _this.updateAnimationKey_;
    _this.projection_ = createProjection(options.projection, "EPSG:3857");
    _this.viewportSize_ = [100, 100];
    _this.targetCenter_ = null;
    _this.targetResolution_;
    _this.targetRotation_;
    _this.nextCenter_ = null;
    _this.nextResolution_;
    _this.nextRotation_;
    _this.cancelAnchor_ = void 0;
    if (options.projection) {
      disableCoordinateWarning();
    }
    if (options.center) {
      options.center = fromUserCoordinate(options.center, _this.projection_);
    }
    if (options.extent) {
      options.extent = fromUserExtent(options.extent, _this.projection_);
    }
    _this.applyOptions_(options);
    return _this;
  }
  View2.prototype.applyOptions_ = function(options) {
    var properties = assign({}, options);
    for (var key in ViewProperty_default) {
      delete properties[key];
    }
    this.setProperties(properties, true);
    var resolutionConstraintInfo = createResolutionConstraint(options);
    this.maxResolution_ = resolutionConstraintInfo.maxResolution;
    this.minResolution_ = resolutionConstraintInfo.minResolution;
    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
    this.resolutions_ = options.resolutions;
    this.padding_ = options.padding;
    this.minZoom_ = resolutionConstraintInfo.minZoom;
    var centerConstraint = createCenterConstraint(options);
    var resolutionConstraint = resolutionConstraintInfo.constraint;
    var rotationConstraint = createRotationConstraint(options);
    this.constraints_ = {
      center: centerConstraint,
      resolution: resolutionConstraint,
      rotation: rotationConstraint
    };
    this.setRotation(options.rotation !== void 0 ? options.rotation : 0);
    this.setCenterInternal(options.center !== void 0 ? options.center : null);
    if (options.resolution !== void 0) {
      this.setResolution(options.resolution);
    } else if (options.zoom !== void 0) {
      this.setZoom(options.zoom);
    }
  };
  Object.defineProperty(View2.prototype, "padding", {
    get: function() {
      return this.padding_;
    },
    set: function(padding) {
      var oldPadding = this.padding_;
      this.padding_ = padding;
      var center = this.getCenter();
      if (center) {
        var newPadding = padding || [0, 0, 0, 0];
        oldPadding = oldPadding || [0, 0, 0, 0];
        var resolution = this.getResolution();
        var offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
        var offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
        this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
      }
    },
    enumerable: false,
    configurable: true
  });
  View2.prototype.getUpdatedOptions_ = function(newOptions) {
    var options = this.getProperties();
    if (options.resolution !== void 0) {
      options.resolution = this.getResolution();
    } else {
      options.zoom = this.getZoom();
    }
    options.center = this.getCenterInternal();
    options.rotation = this.getRotation();
    return assign({}, options, newOptions);
  };
  View2.prototype.animate = function(var_args) {
    if (this.isDef() && !this.getAnimating()) {
      this.resolveConstraints(0);
    }
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; ++i) {
      var options = arguments[i];
      if (options.center) {
        options = assign({}, options);
        options.center = fromUserCoordinate(options.center, this.getProjection());
      }
      if (options.anchor) {
        options = assign({}, options);
        options.anchor = fromUserCoordinate(options.anchor, this.getProjection());
      }
      args[i] = options;
    }
    this.animateInternal.apply(this, args);
  };
  View2.prototype.animateInternal = function(var_args) {
    var animationCount = arguments.length;
    var callback;
    if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
      callback = arguments[animationCount - 1];
      --animationCount;
    }
    var i = 0;
    for (; i < animationCount && !this.isDef(); ++i) {
      var state = arguments[i];
      if (state.center) {
        this.setCenterInternal(state.center);
      }
      if (state.zoom !== void 0) {
        this.setZoom(state.zoom);
      } else if (state.resolution) {
        this.setResolution(state.resolution);
      }
      if (state.rotation !== void 0) {
        this.setRotation(state.rotation);
      }
    }
    if (i === animationCount) {
      if (callback) {
        animationCallback(callback, true);
      }
      return;
    }
    var start = Date.now();
    var center = this.targetCenter_.slice();
    var resolution = this.targetResolution_;
    var rotation = this.targetRotation_;
    var series = [];
    for (; i < animationCount; ++i) {
      var options = arguments[i];
      var animation = {
        start,
        complete: false,
        anchor: options.anchor,
        duration: options.duration !== void 0 ? options.duration : 1e3,
        easing: options.easing || inAndOut,
        callback
      };
      if (options.center) {
        animation.sourceCenter = center;
        animation.targetCenter = options.center.slice();
        center = animation.targetCenter;
      }
      if (options.zoom !== void 0) {
        animation.sourceResolution = resolution;
        animation.targetResolution = this.getResolutionForZoom(options.zoom);
        resolution = animation.targetResolution;
      } else if (options.resolution) {
        animation.sourceResolution = resolution;
        animation.targetResolution = options.resolution;
        resolution = animation.targetResolution;
      }
      if (options.rotation !== void 0) {
        animation.sourceRotation = rotation;
        var delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
        animation.targetRotation = rotation + delta;
        rotation = animation.targetRotation;
      }
      if (isNoopAnimation(animation)) {
        animation.complete = true;
      } else {
        start += animation.duration;
      }
      series.push(animation);
    }
    this.animations_.push(series);
    this.setHint(ViewHint_default.ANIMATING, 1);
    this.updateAnimations_();
  };
  View2.prototype.getAnimating = function() {
    return this.hints_[ViewHint_default.ANIMATING] > 0;
  };
  View2.prototype.getInteracting = function() {
    return this.hints_[ViewHint_default.INTERACTING] > 0;
  };
  View2.prototype.cancelAnimations = function() {
    this.setHint(ViewHint_default.ANIMATING, -this.hints_[ViewHint_default.ANIMATING]);
    var anchor;
    for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
      var series = this.animations_[i];
      if (series[0].callback) {
        animationCallback(series[0].callback, false);
      }
      if (!anchor) {
        for (var j = 0, jj = series.length; j < jj; ++j) {
          var animation = series[j];
          if (!animation.complete) {
            anchor = animation.anchor;
            break;
          }
        }
      }
    }
    this.animations_.length = 0;
    this.cancelAnchor_ = anchor;
    this.nextCenter_ = null;
    this.nextResolution_ = NaN;
    this.nextRotation_ = NaN;
  };
  View2.prototype.updateAnimations_ = function() {
    if (this.updateAnimationKey_ !== void 0) {
      cancelAnimationFrame(this.updateAnimationKey_);
      this.updateAnimationKey_ = void 0;
    }
    if (!this.getAnimating()) {
      return;
    }
    var now = Date.now();
    var more = false;
    for (var i = this.animations_.length - 1; i >= 0; --i) {
      var series = this.animations_[i];
      var seriesComplete = true;
      for (var j = 0, jj = series.length; j < jj; ++j) {
        var animation = series[j];
        if (animation.complete) {
          continue;
        }
        var elapsed = now - animation.start;
        var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
        if (fraction >= 1) {
          animation.complete = true;
          fraction = 1;
        } else {
          seriesComplete = false;
        }
        var progress = animation.easing(fraction);
        if (animation.sourceCenter) {
          var x0 = animation.sourceCenter[0];
          var y0 = animation.sourceCenter[1];
          var x1 = animation.targetCenter[0];
          var y1 = animation.targetCenter[1];
          this.nextCenter_ = animation.targetCenter;
          var x = x0 + progress * (x1 - x0);
          var y = y0 + progress * (y1 - y0);
          this.targetCenter_ = [x, y];
        }
        if (animation.sourceResolution && animation.targetResolution) {
          var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
          if (animation.anchor) {
            var size = this.getViewportSize_(this.getRotation());
            var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
            this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
          }
          this.nextResolution_ = animation.targetResolution;
          this.targetResolution_ = resolution;
          this.applyTargetState_(true);
        }
        if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {
          var rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
          if (animation.anchor) {
            var constrainedRotation = this.constraints_.rotation(rotation, true);
            this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
          }
          this.nextRotation_ = animation.targetRotation;
          this.targetRotation_ = rotation;
        }
        this.applyTargetState_(true);
        more = true;
        if (!animation.complete) {
          break;
        }
      }
      if (seriesComplete) {
        this.animations_[i] = null;
        this.setHint(ViewHint_default.ANIMATING, -1);
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
        var callback = series[0].callback;
        if (callback) {
          animationCallback(callback, true);
        }
      }
    }
    this.animations_ = this.animations_.filter(Boolean);
    if (more && this.updateAnimationKey_ === void 0) {
      this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
    }
  };
  View2.prototype.calculateCenterRotate = function(rotation, anchor) {
    var center;
    var currentCenter = this.getCenterInternal();
    if (currentCenter !== void 0) {
      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
      rotate(center, rotation - this.getRotation());
      add(center, anchor);
    }
    return center;
  };
  View2.prototype.calculateCenterZoom = function(resolution, anchor) {
    var center;
    var currentCenter = this.getCenterInternal();
    var currentResolution = this.getResolution();
    if (currentCenter !== void 0 && currentResolution !== void 0) {
      var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
      var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
      center = [x, y];
    }
    return center;
  };
  View2.prototype.getViewportSize_ = function(opt_rotation) {
    var size = this.viewportSize_;
    if (opt_rotation) {
      var w = size[0];
      var h = size[1];
      return [
        Math.abs(w * Math.cos(opt_rotation)) + Math.abs(h * Math.sin(opt_rotation)),
        Math.abs(w * Math.sin(opt_rotation)) + Math.abs(h * Math.cos(opt_rotation))
      ];
    } else {
      return size;
    }
  };
  View2.prototype.setViewportSize = function(opt_size) {
    this.viewportSize_ = Array.isArray(opt_size) ? opt_size.slice() : [100, 100];
    if (!this.getAnimating()) {
      this.resolveConstraints(0);
    }
  };
  View2.prototype.getCenter = function() {
    var center = this.getCenterInternal();
    if (!center) {
      return center;
    }
    return toUserCoordinate(center, this.getProjection());
  };
  View2.prototype.getCenterInternal = function() {
    return this.get(ViewProperty_default.CENTER);
  };
  View2.prototype.getConstraints = function() {
    return this.constraints_;
  };
  View2.prototype.getConstrainResolution = function() {
    return this.get("constrainResolution");
  };
  View2.prototype.getHints = function(opt_hints) {
    if (opt_hints !== void 0) {
      opt_hints[0] = this.hints_[0];
      opt_hints[1] = this.hints_[1];
      return opt_hints;
    } else {
      return this.hints_.slice();
    }
  };
  View2.prototype.calculateExtent = function(opt_size) {
    var extent = this.calculateExtentInternal(opt_size);
    return toUserExtent(extent, this.getProjection());
  };
  View2.prototype.calculateExtentInternal = function(opt_size) {
    var size = opt_size || this.getViewportSizeMinusPadding_();
    var center = this.getCenterInternal();
    assert(center, 1);
    var resolution = this.getResolution();
    assert(resolution !== void 0, 2);
    var rotation = this.getRotation();
    assert(rotation !== void 0, 3);
    return getForViewAndSize(center, resolution, rotation, size);
  };
  View2.prototype.getMaxResolution = function() {
    return this.maxResolution_;
  };
  View2.prototype.getMinResolution = function() {
    return this.minResolution_;
  };
  View2.prototype.getMaxZoom = function() {
    return this.getZoomForResolution(this.minResolution_);
  };
  View2.prototype.setMaxZoom = function(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
  };
  View2.prototype.getMinZoom = function() {
    return this.getZoomForResolution(this.maxResolution_);
  };
  View2.prototype.setMinZoom = function(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
  };
  View2.prototype.setConstrainResolution = function(enabled) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
  };
  View2.prototype.getProjection = function() {
    return this.projection_;
  };
  View2.prototype.getResolution = function() {
    return this.get(ViewProperty_default.RESOLUTION);
  };
  View2.prototype.getResolutions = function() {
    return this.resolutions_;
  };
  View2.prototype.getResolutionForExtent = function(extent, opt_size) {
    return this.getResolutionForExtentInternal(fromUserExtent(extent, this.getProjection()), opt_size);
  };
  View2.prototype.getResolutionForExtentInternal = function(extent, opt_size) {
    var size = opt_size || this.getViewportSizeMinusPadding_();
    var xResolution = getWidth(extent) / size[0];
    var yResolution = getHeight(extent) / size[1];
    return Math.max(xResolution, yResolution);
  };
  View2.prototype.getResolutionForValueFunction = function(opt_power) {
    var power = opt_power || 2;
    var maxResolution = this.getConstrainedResolution(this.maxResolution_);
    var minResolution = this.minResolution_;
    var max = Math.log(maxResolution / minResolution) / Math.log(power);
    return function(value) {
      var resolution = maxResolution / Math.pow(power, value * max);
      return resolution;
    };
  };
  View2.prototype.getRotation = function() {
    return this.get(ViewProperty_default.ROTATION);
  };
  View2.prototype.getValueForResolutionFunction = function(opt_power) {
    var logPower = Math.log(opt_power || 2);
    var maxResolution = this.getConstrainedResolution(this.maxResolution_);
    var minResolution = this.minResolution_;
    var max = Math.log(maxResolution / minResolution) / logPower;
    return function(resolution) {
      var value = Math.log(maxResolution / resolution) / logPower / max;
      return value;
    };
  };
  View2.prototype.getViewportSizeMinusPadding_ = function(opt_rotation) {
    var size = this.getViewportSize_(opt_rotation);
    var padding = this.padding_;
    if (padding) {
      size = [
        size[0] - padding[1] - padding[3],
        size[1] - padding[0] - padding[2]
      ];
    }
    return size;
  };
  View2.prototype.getState = function() {
    var projection = this.getProjection();
    var resolution = this.getResolution();
    var rotation = this.getRotation();
    var center = this.getCenterInternal();
    var padding = this.padding_;
    if (padding) {
      var reducedSize = this.getViewportSizeMinusPadding_();
      center = calculateCenterOn(center, this.getViewportSize_(), [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
    }
    return {
      center: center.slice(0),
      projection: projection !== void 0 ? projection : null,
      resolution,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation,
      zoom: this.getZoom()
    };
  };
  View2.prototype.getZoom = function() {
    var zoom;
    var resolution = this.getResolution();
    if (resolution !== void 0) {
      zoom = this.getZoomForResolution(resolution);
    }
    return zoom;
  };
  View2.prototype.getZoomForResolution = function(resolution) {
    var offset = this.minZoom_ || 0;
    var max, zoomFactor;
    if (this.resolutions_) {
      var nearest = linearFindNearest(this.resolutions_, resolution, 1);
      offset = nearest;
      max = this.resolutions_[nearest];
      if (nearest == this.resolutions_.length - 1) {
        zoomFactor = 2;
      } else {
        zoomFactor = max / this.resolutions_[nearest + 1];
      }
    } else {
      max = this.maxResolution_;
      zoomFactor = this.zoomFactor_;
    }
    return offset + Math.log(max / resolution) / Math.log(zoomFactor);
  };
  View2.prototype.getResolutionForZoom = function(zoom) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1) {
        return 0;
      }
      var baseLevel = clamp(Math.floor(zoom), 0, this.resolutions_.length - 2);
      var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
      return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
    } else {
      return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
    }
  };
  View2.prototype.fit = function(geometryOrExtent, opt_options) {
    var geometry;
    assert(Array.isArray(geometryOrExtent) || typeof geometryOrExtent.getSimplifiedGeometry === "function", 24);
    if (Array.isArray(geometryOrExtent)) {
      assert(!isEmpty(geometryOrExtent), 25);
      var extent = fromUserExtent(geometryOrExtent, this.getProjection());
      geometry = fromExtent(extent);
    } else if (geometryOrExtent.getType() === "Circle") {
      var extent = fromUserExtent(geometryOrExtent.getExtent(), this.getProjection());
      geometry = fromExtent(extent);
      geometry.rotate(this.getRotation(), getCenter(extent));
    } else {
      var userProjection = getUserProjection();
      if (userProjection) {
        geometry = geometryOrExtent.clone().transform(userProjection, this.getProjection());
      } else {
        geometry = geometryOrExtent;
      }
    }
    this.fitInternal(geometry, opt_options);
  };
  View2.prototype.rotatedExtentForGeometry = function(geometry) {
    var rotation = this.getRotation();
    var cosAngle = Math.cos(rotation);
    var sinAngle = Math.sin(-rotation);
    var coords = geometry.getFlatCoordinates();
    var stride = geometry.getStride();
    var minRotX = Infinity;
    var minRotY = Infinity;
    var maxRotX = -Infinity;
    var maxRotY = -Infinity;
    for (var i = 0, ii = coords.length; i < ii; i += stride) {
      var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
      var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
      minRotX = Math.min(minRotX, rotX);
      minRotY = Math.min(minRotY, rotY);
      maxRotX = Math.max(maxRotX, rotX);
      maxRotY = Math.max(maxRotY, rotY);
    }
    return [minRotX, minRotY, maxRotX, maxRotY];
  };
  View2.prototype.fitInternal = function(geometry, opt_options) {
    var options = opt_options || {};
    var size = options.size;
    if (!size) {
      size = this.getViewportSizeMinusPadding_();
    }
    var padding = options.padding !== void 0 ? options.padding : [0, 0, 0, 0];
    var nearest = options.nearest !== void 0 ? options.nearest : false;
    var minResolution;
    if (options.minResolution !== void 0) {
      minResolution = options.minResolution;
    } else if (options.maxZoom !== void 0) {
      minResolution = this.getResolutionForZoom(options.maxZoom);
    } else {
      minResolution = 0;
    }
    var rotatedExtent = this.rotatedExtentForGeometry(geometry);
    var resolution = this.getResolutionForExtentInternal(rotatedExtent, [
      size[0] - padding[1] - padding[3],
      size[1] - padding[0] - padding[2]
    ]);
    resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
    var rotation = this.getRotation();
    var sinAngle = Math.sin(rotation);
    var cosAngle = Math.cos(rotation);
    var centerRot = getCenter(rotatedExtent);
    centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
    centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
    var centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
    var centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
    var center = this.getConstrainedCenter([centerX, centerY], resolution);
    var callback = options.callback ? options.callback : VOID;
    if (options.duration !== void 0) {
      this.animateInternal({
        resolution,
        center,
        duration: options.duration,
        easing: options.easing
      }, callback);
    } else {
      this.targetResolution_ = resolution;
      this.targetCenter_ = center;
      this.applyTargetState_(false, true);
      animationCallback(callback, true);
    }
  };
  View2.prototype.centerOn = function(coordinate, size, position) {
    this.centerOnInternal(fromUserCoordinate(coordinate, this.getProjection()), size, position);
  };
  View2.prototype.centerOnInternal = function(coordinate, size, position) {
    this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));
  };
  View2.prototype.calculateCenterShift = function(center, resolution, rotation, size) {
    var centerShift;
    var padding = this.padding_;
    if (padding && center) {
      var reducedSize = this.getViewportSizeMinusPadding_(-rotation);
      var shiftedCenter = calculateCenterOn(center, size, [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
      centerShift = [
        center[0] - shiftedCenter[0],
        center[1] - shiftedCenter[1]
      ];
    }
    return centerShift;
  };
  View2.prototype.isDef = function() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  };
  View2.prototype.adjustCenter = function(deltaCoordinates) {
    var center = toUserCoordinate(this.targetCenter_, this.getProjection());
    this.setCenter([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1]
    ]);
  };
  View2.prototype.adjustCenterInternal = function(deltaCoordinates) {
    var center = this.targetCenter_;
    this.setCenterInternal([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1]
    ]);
  };
  View2.prototype.adjustResolution = function(ratio, opt_anchor) {
    var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());
    this.adjustResolutionInternal(ratio, anchor);
  };
  View2.prototype.adjustResolutionInternal = function(ratio, opt_anchor) {
    var isMoving = this.getAnimating() || this.getInteracting();
    var size = this.getViewportSize_(this.getRotation());
    var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);
    if (opt_anchor) {
      this.targetCenter_ = this.calculateCenterZoom(newResolution, opt_anchor);
    }
    this.targetResolution_ *= ratio;
    this.applyTargetState_();
  };
  View2.prototype.adjustZoom = function(delta, opt_anchor) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), opt_anchor);
  };
  View2.prototype.adjustRotation = function(delta, opt_anchor) {
    if (opt_anchor) {
      opt_anchor = fromUserCoordinate(opt_anchor, this.getProjection());
    }
    this.adjustRotationInternal(delta, opt_anchor);
  };
  View2.prototype.adjustRotationInternal = function(delta, opt_anchor) {
    var isMoving = this.getAnimating() || this.getInteracting();
    var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);
    if (opt_anchor) {
      this.targetCenter_ = this.calculateCenterRotate(newRotation, opt_anchor);
    }
    this.targetRotation_ += delta;
    this.applyTargetState_();
  };
  View2.prototype.setCenter = function(center) {
    this.setCenterInternal(center ? fromUserCoordinate(center, this.getProjection()) : center);
  };
  View2.prototype.setCenterInternal = function(center) {
    this.targetCenter_ = center;
    this.applyTargetState_();
  };
  View2.prototype.setHint = function(hint, delta) {
    this.hints_[hint] += delta;
    this.changed();
    return this.hints_[hint];
  };
  View2.prototype.setResolution = function(resolution) {
    this.targetResolution_ = resolution;
    this.applyTargetState_();
  };
  View2.prototype.setRotation = function(rotation) {
    this.targetRotation_ = rotation;
    this.applyTargetState_();
  };
  View2.prototype.setZoom = function(zoom) {
    this.setResolution(this.getResolutionForZoom(zoom));
  };
  View2.prototype.applyTargetState_ = function(opt_doNotCancelAnims, opt_forceMoving) {
    var isMoving = this.getAnimating() || this.getInteracting() || opt_forceMoving;
    var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
    var size = this.getViewportSize_(newRotation);
    var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
    var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
    if (this.get(ViewProperty_default.ROTATION) !== newRotation) {
      this.set(ViewProperty_default.ROTATION, newRotation);
    }
    if (this.get(ViewProperty_default.RESOLUTION) !== newResolution) {
      this.set(ViewProperty_default.RESOLUTION, newResolution);
      this.set("zoom", this.getZoom(), true);
    }
    if (!newCenter || !this.get(ViewProperty_default.CENTER) || !equals3(this.get(ViewProperty_default.CENTER), newCenter)) {
      this.set(ViewProperty_default.CENTER, newCenter);
    }
    if (this.getAnimating() && !opt_doNotCancelAnims) {
      this.cancelAnimations();
    }
    this.cancelAnchor_ = void 0;
  };
  View2.prototype.resolveConstraints = function(opt_duration, opt_resolutionDirection, opt_anchor) {
    var duration = opt_duration !== void 0 ? opt_duration : 200;
    var direction = opt_resolutionDirection || 0;
    var newRotation = this.constraints_.rotation(this.targetRotation_);
    var size = this.getViewportSize_(newRotation);
    var newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
    var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
    if (duration === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = newResolution;
      this.targetRotation_ = newRotation;
      this.targetCenter_ = newCenter;
      this.applyTargetState_();
      return;
    }
    var anchor = opt_anchor || (duration === 0 ? this.cancelAnchor_ : void 0);
    this.cancelAnchor_ = void 0;
    if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals3(this.getCenterInternal(), newCenter)) {
      if (this.getAnimating()) {
        this.cancelAnimations();
      }
      this.animateInternal({
        rotation: newRotation,
        center: newCenter,
        resolution: newResolution,
        duration,
        easing: easeOut,
        anchor
      });
    }
  };
  View2.prototype.beginInteraction = function() {
    this.resolveConstraints(0);
    this.setHint(ViewHint_default.INTERACTING, 1);
  };
  View2.prototype.endInteraction = function(opt_duration, opt_resolutionDirection, opt_anchor) {
    var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());
    this.endInteractionInternal(opt_duration, opt_resolutionDirection, anchor);
  };
  View2.prototype.endInteractionInternal = function(opt_duration, opt_resolutionDirection, opt_anchor) {
    this.setHint(ViewHint_default.INTERACTING, -1);
    this.resolveConstraints(opt_duration, opt_resolutionDirection, opt_anchor);
  };
  View2.prototype.getConstrainedCenter = function(targetCenter, opt_targetResolution) {
    var size = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(targetCenter, opt_targetResolution || this.getResolution(), size);
  };
  View2.prototype.getConstrainedZoom = function(targetZoom, opt_direction) {
    var targetRes = this.getResolutionForZoom(targetZoom);
    return this.getZoomForResolution(this.getConstrainedResolution(targetRes, opt_direction));
  };
  View2.prototype.getConstrainedResolution = function(targetResolution, opt_direction) {
    var direction = opt_direction || 0;
    var size = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(targetResolution, direction, size);
  };
  return View2;
}(Object_default);
function animationCallback(callback, returnValue) {
  setTimeout(function() {
    callback(returnValue);
  }, 0);
}
function createCenterConstraint(options) {
  if (options.extent !== void 0) {
    var smooth = options.smoothExtentConstraint !== void 0 ? options.smoothExtentConstraint : true;
    return createExtent(options.extent, options.constrainOnlyCenter, smooth);
  }
  var projection = createProjection(options.projection, "EPSG:3857");
  if (options.multiWorld !== true && projection.isGlobal()) {
    var extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return createExtent(extent, false, false);
  }
  return none;
}
function createResolutionConstraint(options) {
  var resolutionConstraint;
  var maxResolution;
  var minResolution;
  var defaultMaxZoom = 28;
  var defaultZoomFactor = 2;
  var minZoom = options.minZoom !== void 0 ? options.minZoom : DEFAULT_MIN_ZOOM;
  var maxZoom = options.maxZoom !== void 0 ? options.maxZoom : defaultMaxZoom;
  var zoomFactor = options.zoomFactor !== void 0 ? options.zoomFactor : defaultZoomFactor;
  var multiWorld = options.multiWorld !== void 0 ? options.multiWorld : false;
  var smooth = options.smoothResolutionConstraint !== void 0 ? options.smoothResolutionConstraint : true;
  var showFullExtent = options.showFullExtent !== void 0 ? options.showFullExtent : false;
  var projection = createProjection(options.projection, "EPSG:3857");
  var projExtent = projection.getExtent();
  var constrainOnlyCenter = options.constrainOnlyCenter;
  var extent = options.extent;
  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }
  if (options.resolutions !== void 0) {
    var resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToResolutions(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
    } else {
      resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
  } else {
    var size = !projExtent ? 360 * METERS_PER_UNIT[Units_default.DEGREES] / projection.getMetersPerUnit() : Math.max(getWidth(projExtent), getHeight(projExtent));
    var defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
    maxResolution = options.maxResolution;
    if (maxResolution !== void 0) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }
    minResolution = options.minResolution;
    if (minResolution === void 0) {
      if (options.maxZoom !== void 0) {
        if (options.maxResolution !== void 0) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }
    maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    } else {
      resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
  }
  return {
    constraint: resolutionConstraint,
    maxResolution,
    minResolution,
    minZoom,
    zoomFactor
  };
}
function createRotationConstraint(options) {
  var enableRotation = options.enableRotation !== void 0 ? options.enableRotation : true;
  if (enableRotation) {
    var constrainRotation = options.constrainRotation;
    if (constrainRotation === void 0 || constrainRotation === true) {
      return createSnapToZero();
    } else if (constrainRotation === false) {
      return none2;
    } else if (typeof constrainRotation === "number") {
      return createSnapToN(constrainRotation);
    } else {
      return none2;
    }
  } else {
    return disable;
  }
}
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!equals3(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}
function calculateCenterOn(coordinate, size, position, resolution, rotation) {
  var cosAngle = Math.cos(-rotation);
  var sinAngle = Math.sin(-rotation);
  var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution;
  sinAngle = -sinAngle;
  var centerX = rotX * cosAngle - rotY * sinAngle;
  var centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}
var View_default = View;

// node_modules/ol/PluggableMap.js
var __extends8 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
function removeLayerMapProperty(layer) {
  if (layer instanceof Layer_default) {
    layer.setMapInternal(null);
    return;
  }
  if (layer instanceof Group_default) {
    layer.getLayers().forEach(removeLayerMapProperty);
  }
}
function setLayerMapProperty(layer, map) {
  if (layer instanceof Layer_default) {
    layer.setMapInternal(map);
    return;
  }
  if (layer instanceof Group_default) {
    var layers = layer.getLayers().getArray();
    for (var i = 0, ii = layers.length; i < ii; ++i) {
      setLayerMapProperty(layers[i], map);
    }
  }
}
var PluggableMap = function(_super) {
  __extends8(PluggableMap2, _super);
  function PluggableMap2(options) {
    var _this = _super.call(this) || this;
    _this.on;
    _this.once;
    _this.un;
    var optionsInternal = createOptionsInternal(options);
    _this.renderComplete_;
    _this.loaded_ = true;
    _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);
    _this.maxTilesLoading_ = options.maxTilesLoading !== void 0 ? options.maxTilesLoading : 16;
    _this.pixelRatio_ = options.pixelRatio !== void 0 ? options.pixelRatio : DEVICE_PIXEL_RATIO;
    _this.postRenderTimeoutHandle_;
    _this.animationDelayKey_;
    _this.animationDelay_ = function() {
      this.animationDelayKey_ = void 0;
      this.renderFrame_(Date.now());
    }.bind(_this);
    _this.coordinateToPixelTransform_ = create();
    _this.pixelToCoordinateTransform_ = create();
    _this.frameIndex_ = 0;
    _this.frameState_ = null;
    _this.previousExtent_ = null;
    _this.viewPropertyListenerKey_ = null;
    _this.viewChangeListenerKey_ = null;
    _this.layerGroupPropertyListenerKeys_ = null;
    _this.viewport_ = document.createElement("div");
    _this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : "");
    _this.viewport_.style.position = "relative";
    _this.viewport_.style.overflow = "hidden";
    _this.viewport_.style.width = "100%";
    _this.viewport_.style.height = "100%";
    _this.overlayContainer_ = document.createElement("div");
    _this.overlayContainer_.style.position = "absolute";
    _this.overlayContainer_.style.zIndex = "0";
    _this.overlayContainer_.style.width = "100%";
    _this.overlayContainer_.style.height = "100%";
    _this.overlayContainer_.style.pointerEvents = "none";
    _this.overlayContainer_.className = "ol-overlaycontainer";
    _this.viewport_.appendChild(_this.overlayContainer_);
    _this.overlayContainerStopEvent_ = document.createElement("div");
    _this.overlayContainerStopEvent_.style.position = "absolute";
    _this.overlayContainerStopEvent_.style.zIndex = "0";
    _this.overlayContainerStopEvent_.style.width = "100%";
    _this.overlayContainerStopEvent_.style.height = "100%";
    _this.overlayContainerStopEvent_.style.pointerEvents = "none";
    _this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent";
    _this.viewport_.appendChild(_this.overlayContainerStopEvent_);
    _this.mapBrowserEventHandler_ = null;
    _this.moveTolerance_ = options.moveTolerance;
    _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
    _this.targetChangeHandlerKeys_ = null;
    _this.controls = optionsInternal.controls || new Collection_default();
    _this.interactions = optionsInternal.interactions || new Collection_default();
    _this.overlays_ = optionsInternal.overlays;
    _this.overlayIdIndex_ = {};
    _this.renderer_ = null;
    _this.postRenderFunctions_ = [];
    _this.tileQueue_ = new TileQueue_default(_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));
    _this.addChangeListener(MapProperty_default.LAYERGROUP, _this.handleLayerGroupChanged_);
    _this.addChangeListener(MapProperty_default.VIEW, _this.handleViewChanged_);
    _this.addChangeListener(MapProperty_default.SIZE, _this.handleSizeChanged_);
    _this.addChangeListener(MapProperty_default.TARGET, _this.handleTargetChanged_);
    _this.setProperties(optionsInternal.values);
    var map = _this;
    if (options.view && !(options.view instanceof View_default)) {
      options.view.then(function(viewOptions) {
        map.setView(new View_default(viewOptions));
      });
    }
    _this.controls.addEventListener(
      CollectionEventType_default.ADD,
      function(event) {
        event.element.setMap(this);
      }.bind(_this)
    );
    _this.controls.addEventListener(
      CollectionEventType_default.REMOVE,
      function(event) {
        event.element.setMap(null);
      }.bind(_this)
    );
    _this.interactions.addEventListener(
      CollectionEventType_default.ADD,
      function(event) {
        event.element.setMap(this);
      }.bind(_this)
    );
    _this.interactions.addEventListener(
      CollectionEventType_default.REMOVE,
      function(event) {
        event.element.setMap(null);
      }.bind(_this)
    );
    _this.overlays_.addEventListener(
      CollectionEventType_default.ADD,
      function(event) {
        this.addOverlayInternal_(
          event.element
        );
      }.bind(_this)
    );
    _this.overlays_.addEventListener(
      CollectionEventType_default.REMOVE,
      function(event) {
        var overlay = event.element;
        var id = overlay.getId();
        if (id !== void 0) {
          delete this.overlayIdIndex_[id.toString()];
        }
        event.element.setMap(null);
      }.bind(_this)
    );
    _this.controls.forEach(
      function(control) {
        control.setMap(this);
      }.bind(_this)
    );
    _this.interactions.forEach(
      function(interaction) {
        interaction.setMap(this);
      }.bind(_this)
    );
    _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));
    return _this;
  }
  PluggableMap2.prototype.createRenderer = function() {
    throw new Error("Use a map type that has a createRenderer method");
  };
  PluggableMap2.prototype.addControl = function(control) {
    this.getControls().push(control);
  };
  PluggableMap2.prototype.addInteraction = function(interaction) {
    this.getInteractions().push(interaction);
  };
  PluggableMap2.prototype.addLayer = function(layer) {
    var layers = this.getLayerGroup().getLayers();
    layers.push(layer);
  };
  PluggableMap2.prototype.handleLayerAdd_ = function(event) {
    setLayerMapProperty(event.layer, this);
  };
  PluggableMap2.prototype.addOverlay = function(overlay) {
    this.getOverlays().push(overlay);
  };
  PluggableMap2.prototype.addOverlayInternal_ = function(overlay) {
    var id = overlay.getId();
    if (id !== void 0) {
      this.overlayIdIndex_[id.toString()] = overlay;
    }
    overlay.setMap(this);
  };
  PluggableMap2.prototype.disposeInternal = function() {
    this.controls.clear();
    this.interactions.clear();
    this.overlays_.clear();
    this.setTarget(null);
    _super.prototype.disposeInternal.call(this);
  };
  PluggableMap2.prototype.forEachFeatureAtPixel = function(pixel, callback, opt_options) {
    if (!this.frameState_ || !this.renderer_) {
      return;
    }
    var coordinate = this.getCoordinateFromPixelInternal(pixel);
    opt_options = opt_options !== void 0 ? opt_options : {};
    var hitTolerance = opt_options.hitTolerance !== void 0 ? opt_options.hitTolerance : 0;
    var layerFilter = opt_options.layerFilter !== void 0 ? opt_options.layerFilter : TRUE;
    var checkWrapped = opt_options.checkWrapped !== false;
    return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
  };
  PluggableMap2.prototype.getFeaturesAtPixel = function(pixel, opt_options) {
    var features = [];
    this.forEachFeatureAtPixel(pixel, function(feature) {
      features.push(feature);
    }, opt_options);
    return features;
  };
  PluggableMap2.prototype.getAllLayers = function() {
    var layers = [];
    function addLayersFrom(layerGroup) {
      layerGroup.forEach(function(layer) {
        if (layer instanceof Group_default) {
          addLayersFrom(layer.getLayers());
        } else {
          layers.push(layer);
        }
      });
    }
    addLayersFrom(this.getLayers());
    return layers;
  };
  PluggableMap2.prototype.forEachLayerAtPixel = function(pixel, callback, opt_options) {
    if (!this.frameState_ || !this.renderer_) {
      return;
    }
    var options = opt_options || {};
    var hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
    var layerFilter = options.layerFilter || TRUE;
    return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);
  };
  PluggableMap2.prototype.hasFeatureAtPixel = function(pixel, opt_options) {
    if (!this.frameState_ || !this.renderer_) {
      return false;
    }
    var coordinate = this.getCoordinateFromPixelInternal(pixel);
    opt_options = opt_options !== void 0 ? opt_options : {};
    var layerFilter = opt_options.layerFilter !== void 0 ? opt_options.layerFilter : TRUE;
    var hitTolerance = opt_options.hitTolerance !== void 0 ? opt_options.hitTolerance : 0;
    var checkWrapped = opt_options.checkWrapped !== false;
    return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
  };
  PluggableMap2.prototype.getEventCoordinate = function(event) {
    return this.getCoordinateFromPixel(this.getEventPixel(event));
  };
  PluggableMap2.prototype.getEventCoordinateInternal = function(event) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
  };
  PluggableMap2.prototype.getEventPixel = function(event) {
    var viewportPosition = this.viewport_.getBoundingClientRect();
    var eventPosition = "changedTouches" in event ? event.changedTouches[0] : event;
    return [
      eventPosition.clientX - viewportPosition.left,
      eventPosition.clientY - viewportPosition.top
    ];
  };
  PluggableMap2.prototype.getTarget = function() {
    return this.get(MapProperty_default.TARGET);
  };
  PluggableMap2.prototype.getTargetElement = function() {
    var target = this.getTarget();
    if (target !== void 0) {
      return typeof target === "string" ? document.getElementById(target) : target;
    } else {
      return null;
    }
  };
  PluggableMap2.prototype.getCoordinateFromPixel = function(pixel) {
    return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
  };
  PluggableMap2.prototype.getCoordinateFromPixelInternal = function(pixel) {
    var frameState = this.frameState_;
    if (!frameState) {
      return null;
    } else {
      return apply(frameState.pixelToCoordinateTransform, pixel.slice());
    }
  };
  PluggableMap2.prototype.getControls = function() {
    return this.controls;
  };
  PluggableMap2.prototype.getOverlays = function() {
    return this.overlays_;
  };
  PluggableMap2.prototype.getOverlayById = function(id) {
    var overlay = this.overlayIdIndex_[id.toString()];
    return overlay !== void 0 ? overlay : null;
  };
  PluggableMap2.prototype.getInteractions = function() {
    return this.interactions;
  };
  PluggableMap2.prototype.getLayerGroup = function() {
    return this.get(MapProperty_default.LAYERGROUP);
  };
  PluggableMap2.prototype.setLayers = function(layers) {
    var group = this.getLayerGroup();
    if (layers instanceof Collection_default) {
      group.setLayers(layers);
      return;
    }
    var collection = group.getLayers();
    collection.clear();
    collection.extend(layers);
  };
  PluggableMap2.prototype.getLayers = function() {
    var layers = this.getLayerGroup().getLayers();
    return layers;
  };
  PluggableMap2.prototype.getLoadingOrNotReady = function() {
    var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      var state = layerStatesArray[i];
      if (!state.visible) {
        continue;
      }
      var renderer = state.layer.getRenderer();
      if (renderer && !renderer.ready) {
        return true;
      }
      var source = state.layer.getSource();
      if (source && source.loading) {
        return true;
      }
    }
    return false;
  };
  PluggableMap2.prototype.getPixelFromCoordinate = function(coordinate) {
    var viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());
    return this.getPixelFromCoordinateInternal(viewCoordinate);
  };
  PluggableMap2.prototype.getPixelFromCoordinateInternal = function(coordinate) {
    var frameState = this.frameState_;
    if (!frameState) {
      return null;
    } else {
      return apply(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
    }
  };
  PluggableMap2.prototype.getRenderer = function() {
    return this.renderer_;
  };
  PluggableMap2.prototype.getSize = function() {
    return this.get(MapProperty_default.SIZE);
  };
  PluggableMap2.prototype.getView = function() {
    return this.get(MapProperty_default.VIEW);
  };
  PluggableMap2.prototype.getViewport = function() {
    return this.viewport_;
  };
  PluggableMap2.prototype.getOverlayContainer = function() {
    return this.overlayContainer_;
  };
  PluggableMap2.prototype.getOverlayContainerStopEvent = function() {
    return this.overlayContainerStopEvent_;
  };
  PluggableMap2.prototype.getOwnerDocument = function() {
    var targetElement = this.getTargetElement();
    return targetElement ? targetElement.ownerDocument : document;
  };
  PluggableMap2.prototype.getTilePriority = function(tile, tileSourceKey, tileCenter, tileResolution) {
    return getTilePriority(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);
  };
  PluggableMap2.prototype.handleBrowserEvent = function(browserEvent, opt_type) {
    var type = opt_type || browserEvent.type;
    var mapBrowserEvent = new MapBrowserEvent_default(type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  };
  PluggableMap2.prototype.handleMapBrowserEvent = function(mapBrowserEvent) {
    if (!this.frameState_) {
      return;
    }
    var originalEvent = mapBrowserEvent.originalEvent;
    var eventType = originalEvent.type;
    if (eventType === EventType_default3.POINTERDOWN || eventType === EventType_default.WHEEL || eventType === EventType_default.KEYDOWN) {
      var doc = this.getOwnerDocument();
      var rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
      var target = originalEvent.target;
      if (this.overlayContainerStopEvent_.contains(target) || !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) {
        return;
      }
    }
    mapBrowserEvent.frameState = this.frameState_;
    if (this.dispatchEvent(mapBrowserEvent) !== false) {
      var interactionsArray = this.getInteractions().getArray().slice();
      for (var i = interactionsArray.length - 1; i >= 0; i--) {
        var interaction = interactionsArray[i];
        if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
          continue;
        }
        var cont = interaction.handleEvent(mapBrowserEvent);
        if (!cont || mapBrowserEvent.propagationStopped) {
          break;
        }
      }
    }
  };
  PluggableMap2.prototype.handlePostRender = function() {
    var frameState = this.frameState_;
    var tileQueue = this.tileQueue_;
    if (!tileQueue.isEmpty()) {
      var maxTotalLoading = this.maxTilesLoading_;
      var maxNewLoads = maxTotalLoading;
      if (frameState) {
        var hints = frameState.viewHints;
        if (hints[ViewHint_default.ANIMATING] || hints[ViewHint_default.INTERACTING]) {
          var lowOnFrameBudget = Date.now() - frameState.time > 8;
          maxTotalLoading = lowOnFrameBudget ? 0 : 8;
          maxNewLoads = lowOnFrameBudget ? 0 : 2;
        }
      }
      if (tileQueue.getTilesLoading() < maxTotalLoading) {
        tileQueue.reprioritize();
        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
      }
    }
    if (frameState && this.renderer_ && !frameState.animate) {
      if (this.renderComplete_ === true) {
        if (this.hasListener(EventType_default2.RENDERCOMPLETE)) {
          this.renderer_.dispatchRenderEvent(EventType_default2.RENDERCOMPLETE, frameState);
        }
        if (this.loaded_ === false) {
          this.loaded_ = true;
          this.dispatchEvent(new MapEvent_default(MapEventType_default.LOADEND, this, frameState));
        }
      } else if (this.loaded_ === true) {
        this.loaded_ = false;
        this.dispatchEvent(new MapEvent_default(MapEventType_default.LOADSTART, this, frameState));
      }
    }
    var postRenderFunctions = this.postRenderFunctions_;
    for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
      postRenderFunctions[i](this, frameState);
    }
    postRenderFunctions.length = 0;
  };
  PluggableMap2.prototype.handleSizeChanged_ = function() {
    if (this.getView() && !this.getView().getAnimating()) {
      this.getView().resolveConstraints(0);
    }
    this.render();
  };
  PluggableMap2.prototype.handleTargetChanged_ = function() {
    if (this.mapBrowserEventHandler_) {
      for (var i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {
        unlistenByKey(this.targetChangeHandlerKeys_[i]);
      }
      this.targetChangeHandlerKeys_ = null;
      this.viewport_.removeEventListener(EventType_default.CONTEXTMENU, this.boundHandleBrowserEvent_);
      this.viewport_.removeEventListener(EventType_default.WHEEL, this.boundHandleBrowserEvent_);
      this.mapBrowserEventHandler_.dispose();
      this.mapBrowserEventHandler_ = null;
      removeNode(this.viewport_);
    }
    var targetElement = this.getTargetElement();
    if (!targetElement) {
      if (this.renderer_) {
        clearTimeout(this.postRenderTimeoutHandle_);
        this.postRenderTimeoutHandle_ = void 0;
        this.postRenderFunctions_.length = 0;
        this.renderer_.dispose();
        this.renderer_ = null;
      }
      if (this.animationDelayKey_) {
        cancelAnimationFrame(this.animationDelayKey_);
        this.animationDelayKey_ = void 0;
      }
    } else {
      targetElement.appendChild(this.viewport_);
      if (!this.renderer_) {
        this.renderer_ = this.createRenderer();
      }
      this.mapBrowserEventHandler_ = new MapBrowserEventHandler_default(this, this.moveTolerance_);
      for (var key in MapBrowserEventType_default) {
        this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType_default[key], this.handleMapBrowserEvent.bind(this));
      }
      this.viewport_.addEventListener(EventType_default.CONTEXTMENU, this.boundHandleBrowserEvent_, false);
      this.viewport_.addEventListener(EventType_default.WHEEL, this.boundHandleBrowserEvent_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);
      var defaultView = this.getOwnerDocument().defaultView;
      var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
      this.targetChangeHandlerKeys_ = [
        listen(keyboardEventTarget, EventType_default.KEYDOWN, this.handleBrowserEvent, this),
        listen(keyboardEventTarget, EventType_default.KEYPRESS, this.handleBrowserEvent, this),
        listen(defaultView, EventType_default.RESIZE, this.updateSize, this)
      ];
    }
    this.updateSize();
  };
  PluggableMap2.prototype.handleTileChange_ = function() {
    this.render();
  };
  PluggableMap2.prototype.handleViewPropertyChanged_ = function() {
    this.render();
  };
  PluggableMap2.prototype.handleViewChanged_ = function() {
    if (this.viewPropertyListenerKey_) {
      unlistenByKey(this.viewPropertyListenerKey_);
      this.viewPropertyListenerKey_ = null;
    }
    if (this.viewChangeListenerKey_) {
      unlistenByKey(this.viewChangeListenerKey_);
      this.viewChangeListenerKey_ = null;
    }
    var view = this.getView();
    if (view) {
      this.updateViewportSize_();
      this.viewPropertyListenerKey_ = listen(view, ObjectEventType_default.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
      this.viewChangeListenerKey_ = listen(view, EventType_default.CHANGE, this.handleViewPropertyChanged_, this);
      view.resolveConstraints(0);
    }
    this.render();
  };
  PluggableMap2.prototype.handleLayerGroupChanged_ = function() {
    if (this.layerGroupPropertyListenerKeys_) {
      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);
      this.layerGroupPropertyListenerKeys_ = null;
    }
    var layerGroup = this.getLayerGroup();
    if (layerGroup) {
      this.handleLayerAdd_(new GroupEvent("addlayer", layerGroup));
      this.layerGroupPropertyListenerKeys_ = [
        listen(layerGroup, ObjectEventType_default.PROPERTYCHANGE, this.render, this),
        listen(layerGroup, EventType_default.CHANGE, this.render, this),
        listen(layerGroup, "addlayer", this.handleLayerAdd_, this),
        listen(layerGroup, "removelayer", this.handleLayerRemove_, this)
      ];
    }
    this.render();
  };
  PluggableMap2.prototype.isRendered = function() {
    return !!this.frameState_;
  };
  PluggableMap2.prototype.renderSync = function() {
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
    }
    this.animationDelay_();
  };
  PluggableMap2.prototype.redrawText = function() {
    var layerStates = this.getLayerGroup().getLayerStatesArray();
    for (var i = 0, ii = layerStates.length; i < ii; ++i) {
      var layer = layerStates[i].layer;
      if (layer.hasRenderer()) {
        layer.getRenderer().handleFontsChanged();
      }
    }
  };
  PluggableMap2.prototype.render = function() {
    if (this.renderer_ && this.animationDelayKey_ === void 0) {
      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
  };
  PluggableMap2.prototype.removeControl = function(control) {
    return this.getControls().remove(control);
  };
  PluggableMap2.prototype.removeInteraction = function(interaction) {
    return this.getInteractions().remove(interaction);
  };
  PluggableMap2.prototype.removeLayer = function(layer) {
    var layers = this.getLayerGroup().getLayers();
    return layers.remove(layer);
  };
  PluggableMap2.prototype.handleLayerRemove_ = function(event) {
    removeLayerMapProperty(event.layer);
  };
  PluggableMap2.prototype.removeOverlay = function(overlay) {
    return this.getOverlays().remove(overlay);
  };
  PluggableMap2.prototype.renderFrame_ = function(time) {
    var _this = this;
    var size = this.getSize();
    var view = this.getView();
    var previousFrameState = this.frameState_;
    var frameState = null;
    if (size !== void 0 && hasArea(size) && view && view.isDef()) {
      var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : void 0);
      var viewState = view.getState();
      frameState = {
        animate: false,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutterTree: null,
        extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size,
        tileQueue: this.tileQueue_,
        time,
        usedTiles: {},
        viewState,
        viewHints,
        wantedTiles: {},
        mapId: getUid(this),
        renderTargets: {}
      };
      if (viewState.nextCenter && viewState.nextResolution) {
        var rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
        frameState.nextExtent = getForViewAndSize(viewState.nextCenter, viewState.nextResolution, rotation, size);
      }
    }
    this.frameState_ = frameState;
    this.renderer_.renderFrame(frameState);
    if (frameState) {
      if (frameState.animate) {
        this.render();
      }
      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);
      if (previousFrameState) {
        var moveStart = !this.previousExtent_ || !isEmpty(this.previousExtent_) && !equals2(frameState.extent, this.previousExtent_);
        if (moveStart) {
          this.dispatchEvent(new MapEvent_default(MapEventType_default.MOVESTART, this, previousFrameState));
          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
        }
      }
      var idle = this.previousExtent_ && !frameState.viewHints[ViewHint_default.ANIMATING] && !frameState.viewHints[ViewHint_default.INTERACTING] && !equals2(frameState.extent, this.previousExtent_);
      if (idle) {
        this.dispatchEvent(new MapEvent_default(MapEventType_default.MOVEEND, this, frameState));
        clone(frameState.extent, this.previousExtent_);
      }
    }
    this.dispatchEvent(new MapEvent_default(MapEventType_default.POSTRENDER, this, frameState));
    this.renderComplete_ = this.hasListener(MapEventType_default.LOADSTART) || this.hasListener(MapEventType_default.LOADEND) || this.hasListener(EventType_default2.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0;
    if (!this.postRenderTimeoutHandle_) {
      this.postRenderTimeoutHandle_ = setTimeout(function() {
        _this.postRenderTimeoutHandle_ = void 0;
        _this.handlePostRender();
      }, 0);
    }
  };
  PluggableMap2.prototype.setLayerGroup = function(layerGroup) {
    var oldLayerGroup = this.getLayerGroup();
    if (oldLayerGroup) {
      this.handleLayerRemove_(new GroupEvent("removelayer", oldLayerGroup));
    }
    this.set(MapProperty_default.LAYERGROUP, layerGroup);
  };
  PluggableMap2.prototype.setSize = function(size) {
    this.set(MapProperty_default.SIZE, size);
  };
  PluggableMap2.prototype.setTarget = function(target) {
    this.set(MapProperty_default.TARGET, target);
  };
  PluggableMap2.prototype.setView = function(view) {
    if (!view || view instanceof View_default) {
      this.set(MapProperty_default.VIEW, view);
      return;
    }
    this.set(MapProperty_default.VIEW, new View_default());
    var map = this;
    view.then(function(viewOptions) {
      map.setView(new View_default(viewOptions));
    });
  };
  PluggableMap2.prototype.updateSize = function() {
    var targetElement = this.getTargetElement();
    var size = void 0;
    if (targetElement) {
      var computedStyle = getComputedStyle(targetElement);
      var width = targetElement.offsetWidth - parseFloat(computedStyle["borderLeftWidth"]) - parseFloat(computedStyle["paddingLeft"]) - parseFloat(computedStyle["paddingRight"]) - parseFloat(computedStyle["borderRightWidth"]);
      var height = targetElement.offsetHeight - parseFloat(computedStyle["borderTopWidth"]) - parseFloat(computedStyle["paddingTop"]) - parseFloat(computedStyle["paddingBottom"]) - parseFloat(computedStyle["borderBottomWidth"]);
      if (!isNaN(width) && !isNaN(height)) {
        size = [width, height];
        if (!hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {
          console.warn("No map visible because the map container's width or height are 0.");
        }
      }
    }
    this.setSize(size);
    this.updateViewportSize_();
  };
  PluggableMap2.prototype.updateViewportSize_ = function() {
    var view = this.getView();
    if (view) {
      var size = void 0;
      var computedStyle = getComputedStyle(this.viewport_);
      if (computedStyle.width && computedStyle.height) {
        size = [
          parseInt(computedStyle.width, 10),
          parseInt(computedStyle.height, 10)
        ];
      }
      view.setViewportSize(size);
    }
  };
  return PluggableMap2;
}(Object_default);
function createOptionsInternal(options) {
  var keyboardEventTarget = null;
  if (options.keyboardEventTarget !== void 0) {
    keyboardEventTarget = typeof options.keyboardEventTarget === "string" ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }
  var values = {};
  var layerGroup = options.layers && typeof options.layers.getLayers === "function" ? options.layers : new Group_default({ layers: options.layers });
  values[MapProperty_default.LAYERGROUP] = layerGroup;
  values[MapProperty_default.TARGET] = options.target;
  values[MapProperty_default.VIEW] = options.view instanceof View_default ? options.view : new View_default();
  var controls;
  if (options.controls !== void 0) {
    if (Array.isArray(options.controls)) {
      controls = new Collection_default(options.controls.slice());
    } else {
      assert(typeof options.controls.getArray === "function", 47);
      controls = options.controls;
    }
  }
  var interactions;
  if (options.interactions !== void 0) {
    if (Array.isArray(options.interactions)) {
      interactions = new Collection_default(options.interactions.slice());
    } else {
      assert(typeof options.interactions.getArray === "function", 48);
      interactions = options.interactions;
    }
  }
  var overlays;
  if (options.overlays !== void 0) {
    if (Array.isArray(options.overlays)) {
      overlays = new Collection_default(options.overlays.slice());
    } else {
      assert(typeof options.overlays.getArray === "function", 49);
      overlays = options.overlays;
    }
  } else {
    overlays = new Collection_default();
  }
  return {
    controls,
    interactions,
    keyboardEventTarget,
    overlays,
    values
  };
}
var PluggableMap_default = PluggableMap;

// node_modules/ol/control/Control.js
var __extends9 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Control = function(_super) {
  __extends9(Control2, _super);
  function Control2(options) {
    var _this = _super.call(this) || this;
    var element = options.element;
    if (element && !options.target && !element.style.pointerEvents) {
      element.style.pointerEvents = "auto";
    }
    _this.element = element ? element : null;
    _this.target_ = null;
    _this.map_ = null;
    _this.listenerKeys = [];
    if (options.render) {
      _this.render = options.render;
    }
    if (options.target) {
      _this.setTarget(options.target);
    }
    return _this;
  }
  Control2.prototype.disposeInternal = function() {
    removeNode(this.element);
    _super.prototype.disposeInternal.call(this);
  };
  Control2.prototype.getMap = function() {
    return this.map_;
  };
  Control2.prototype.setMap = function(map) {
    if (this.map_) {
      removeNode(this.element);
    }
    for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
      unlistenByKey(this.listenerKeys[i]);
    }
    this.listenerKeys.length = 0;
    this.map_ = map;
    if (map) {
      var target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
      target.appendChild(this.element);
      if (this.render !== VOID) {
        this.listenerKeys.push(listen(map, MapEventType_default.POSTRENDER, this.render, this));
      }
      map.render();
    }
  };
  Control2.prototype.render = function(mapEvent) {
  };
  Control2.prototype.setTarget = function(target) {
    this.target_ = typeof target === "string" ? document.getElementById(target) : target;
  };
  return Control2;
}(Object_default);
var Control_default = Control;

// node_modules/ol/control/Attribution.js
var __extends10 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Attribution = function(_super) {
  __extends10(Attribution2, _super);
  function Attribution2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    }) || this;
    _this.ulElement_ = document.createElement("ul");
    _this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
    _this.userCollapsed_ = _this.collapsed_;
    _this.overrideCollapsible_ = options.collapsible !== void 0;
    _this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
    if (!_this.collapsible_) {
      _this.collapsed_ = false;
    }
    var className = options.className !== void 0 ? options.className : "ol-attribution";
    var tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Attributions";
    var expandClassName = options.expandClassName !== void 0 ? options.expandClassName : className + "-expand";
    var collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "\u203A";
    var collapseClassName = options.collapseClassName !== void 0 ? options.collapseClassName : className + "-collapse";
    if (typeof collapseLabel === "string") {
      _this.collapseLabel_ = document.createElement("span");
      _this.collapseLabel_.textContent = collapseLabel;
      _this.collapseLabel_.className = collapseClassName;
    } else {
      _this.collapseLabel_ = collapseLabel;
    }
    var label = options.label !== void 0 ? options.label : "i";
    if (typeof label === "string") {
      _this.label_ = document.createElement("span");
      _this.label_.textContent = label;
      _this.label_.className = expandClassName;
    } else {
      _this.label_ = label;
    }
    var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
    _this.toggleButton_ = document.createElement("button");
    _this.toggleButton_.setAttribute("type", "button");
    _this.toggleButton_.setAttribute("aria-expanded", String(!_this.collapsed_));
    _this.toggleButton_.title = tipLabel;
    _this.toggleButton_.appendChild(activeLabel);
    _this.toggleButton_.addEventListener(EventType_default.CLICK, _this.handleClick_.bind(_this), false);
    var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (_this.collapsible_ ? "" : " ol-uncollapsible");
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(_this.toggleButton_);
    element.appendChild(_this.ulElement_);
    _this.renderedAttributions_ = [];
    _this.renderedVisible_ = true;
    return _this;
  }
  Attribution2.prototype.collectSourceAttributions_ = function(frameState) {
    var lookup = {};
    var visibleAttributions = [];
    var collapsible = true;
    var layerStatesArray = frameState.layerStatesArray;
    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      var layerState = layerStatesArray[i];
      if (!inView(layerState, frameState.viewState)) {
        continue;
      }
      var source = layerState.layer.getSource();
      if (!source) {
        continue;
      }
      var attributionGetter = source.getAttributions();
      if (!attributionGetter) {
        continue;
      }
      var attributions = attributionGetter(frameState);
      if (!attributions) {
        continue;
      }
      collapsible = collapsible && source.getAttributionsCollapsible() !== false;
      if (Array.isArray(attributions)) {
        for (var j = 0, jj = attributions.length; j < jj; ++j) {
          if (!(attributions[j] in lookup)) {
            visibleAttributions.push(attributions[j]);
            lookup[attributions[j]] = true;
          }
        }
      } else {
        if (!(attributions in lookup)) {
          visibleAttributions.push(attributions);
          lookup[attributions] = true;
        }
      }
    }
    if (!this.overrideCollapsible_) {
      this.setCollapsible(collapsible);
    }
    return visibleAttributions;
  };
  Attribution2.prototype.updateElement_ = function(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    var attributions = this.collectSourceAttributions_(frameState);
    var visible = attributions.length > 0;
    if (this.renderedVisible_ != visible) {
      this.element.style.display = visible ? "" : "none";
      this.renderedVisible_ = visible;
    }
    if (equals(attributions, this.renderedAttributions_)) {
      return;
    }
    removeChildren(this.ulElement_);
    for (var i = 0, ii = attributions.length; i < ii; ++i) {
      var element = document.createElement("li");
      element.innerHTML = attributions[i];
      this.ulElement_.appendChild(element);
    }
    this.renderedAttributions_ = attributions;
  };
  Attribution2.prototype.handleClick_ = function(event) {
    event.preventDefault();
    this.handleToggle_();
    this.userCollapsed_ = this.collapsed_;
  };
  Attribution2.prototype.handleToggle_ = function() {
    this.element.classList.toggle(CLASS_COLLAPSED);
    if (this.collapsed_) {
      replaceNode(this.collapseLabel_, this.label_);
    } else {
      replaceNode(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
    this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  };
  Attribution2.prototype.getCollapsible = function() {
    return this.collapsible_;
  };
  Attribution2.prototype.setCollapsible = function(collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle("ol-uncollapsible");
    if (this.userCollapsed_) {
      this.handleToggle_();
    }
  };
  Attribution2.prototype.setCollapsed = function(collapsed) {
    this.userCollapsed_ = collapsed;
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  };
  Attribution2.prototype.getCollapsed = function() {
    return this.collapsed_;
  };
  Attribution2.prototype.render = function(mapEvent) {
    this.updateElement_(mapEvent.frameState);
  };
  return Attribution2;
}(Control_default);
var Attribution_default = Attribution;

// node_modules/ol/control/Rotate.js
var __extends11 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Rotate = function(_super) {
  __extends11(Rotate2, _super);
  function Rotate2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    }) || this;
    var className = options.className !== void 0 ? options.className : "ol-rotate";
    var label = options.label !== void 0 ? options.label : "\u21E7";
    var compassClassName = options.compassClassName !== void 0 ? options.compassClassName : "ol-compass";
    _this.label_ = null;
    if (typeof label === "string") {
      _this.label_ = document.createElement("span");
      _this.label_.className = compassClassName;
      _this.label_.textContent = label;
    } else {
      _this.label_ = label;
      _this.label_.classList.add(compassClassName);
    }
    var tipLabel = options.tipLabel ? options.tipLabel : "Reset rotation";
    var button = document.createElement("button");
    button.className = className + "-reset";
    button.setAttribute("type", "button");
    button.title = tipLabel;
    button.appendChild(_this.label_);
    button.addEventListener(EventType_default.CLICK, _this.handleClick_.bind(_this), false);
    var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(button);
    _this.callResetNorth_ = options.resetNorth ? options.resetNorth : void 0;
    _this.duration_ = options.duration !== void 0 ? options.duration : 250;
    _this.autoHide_ = options.autoHide !== void 0 ? options.autoHide : true;
    _this.rotation_ = void 0;
    if (_this.autoHide_) {
      _this.element.classList.add(CLASS_HIDDEN);
    }
    return _this;
  }
  Rotate2.prototype.handleClick_ = function(event) {
    event.preventDefault();
    if (this.callResetNorth_ !== void 0) {
      this.callResetNorth_();
    } else {
      this.resetNorth_();
    }
  };
  Rotate2.prototype.resetNorth_ = function() {
    var map = this.getMap();
    var view = map.getView();
    if (!view) {
      return;
    }
    var rotation = view.getRotation();
    if (rotation !== void 0) {
      if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
        view.animate({
          rotation: 0,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setRotation(0);
      }
    }
  };
  Rotate2.prototype.render = function(mapEvent) {
    var frameState = mapEvent.frameState;
    if (!frameState) {
      return;
    }
    var rotation = frameState.viewState.rotation;
    if (rotation != this.rotation_) {
      var transform = "rotate(" + rotation + "rad)";
      if (this.autoHide_) {
        var contains = this.element.classList.contains(CLASS_HIDDEN);
        if (!contains && rotation === 0) {
          this.element.classList.add(CLASS_HIDDEN);
        } else if (contains && rotation !== 0) {
          this.element.classList.remove(CLASS_HIDDEN);
        }
      }
      this.label_.style.transform = transform;
    }
    this.rotation_ = rotation;
  };
  return Rotate2;
}(Control_default);
var Rotate_default = Rotate;

// node_modules/ol/control/Zoom.js
var __extends12 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Zoom = function(_super) {
  __extends12(Zoom2, _super);
  function Zoom2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement("div"),
      target: options.target
    }) || this;
    var className = options.className !== void 0 ? options.className : "ol-zoom";
    var delta = options.delta !== void 0 ? options.delta : 1;
    var zoomInClassName = options.zoomInClassName !== void 0 ? options.zoomInClassName : className + "-in";
    var zoomOutClassName = options.zoomOutClassName !== void 0 ? options.zoomOutClassName : className + "-out";
    var zoomInLabel = options.zoomInLabel !== void 0 ? options.zoomInLabel : "+";
    var zoomOutLabel = options.zoomOutLabel !== void 0 ? options.zoomOutLabel : "\u2013";
    var zoomInTipLabel = options.zoomInTipLabel !== void 0 ? options.zoomInTipLabel : "Zoom in";
    var zoomOutTipLabel = options.zoomOutTipLabel !== void 0 ? options.zoomOutTipLabel : "Zoom out";
    var inElement = document.createElement("button");
    inElement.className = zoomInClassName;
    inElement.setAttribute("type", "button");
    inElement.title = zoomInTipLabel;
    inElement.appendChild(typeof zoomInLabel === "string" ? document.createTextNode(zoomInLabel) : zoomInLabel);
    inElement.addEventListener(EventType_default.CLICK, _this.handleClick_.bind(_this, delta), false);
    var outElement = document.createElement("button");
    outElement.className = zoomOutClassName;
    outElement.setAttribute("type", "button");
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(typeof zoomOutLabel === "string" ? document.createTextNode(zoomOutLabel) : zoomOutLabel);
    outElement.addEventListener(EventType_default.CLICK, _this.handleClick_.bind(_this, -delta), false);
    var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);
    _this.duration_ = options.duration !== void 0 ? options.duration : 250;
    return _this;
  }
  Zoom2.prototype.handleClick_ = function(delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
  };
  Zoom2.prototype.zoomByDelta_ = function(delta) {
    var map = this.getMap();
    var view = map.getView();
    if (!view) {
      return;
    }
    var currentZoom = view.getZoom();
    if (currentZoom !== void 0) {
      var newZoom = view.getConstrainedZoom(currentZoom + delta);
      if (this.duration_ > 0) {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.animate({
          zoom: newZoom,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setZoom(newZoom);
      }
    }
  };
  return Zoom2;
}(Control_default);
var Zoom_default = Zoom;

// node_modules/ol/control/FullScreen.js
var __extends13 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var events = [
  "fullscreenchange",
  "webkitfullscreenchange",
  "MSFullscreenChange"
];
var FullScreenEventType = {
  ENTERFULLSCREEN: "enterfullscreen",
  LEAVEFULLSCREEN: "leavefullscreen"
};
var FullScreen = function(_super) {
  __extends13(FullScreen2, _super);
  function FullScreen2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement("div"),
      target: options.target
    }) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.keys_ = options.keys !== void 0 ? options.keys : false;
    _this.source_ = options.source;
    _this.isInFullscreen_ = false;
    _this.boundHandleMapTargetChange_ = _this.handleMapTargetChange_.bind(_this);
    _this.cssClassName_ = options.className !== void 0 ? options.className : "ol-full-screen";
    _this.documentListeners_ = [];
    _this.activeClassName_ = options.activeClassName !== void 0 ? options.activeClassName.split(" ") : [_this.cssClassName_ + "-true"];
    _this.inactiveClassName_ = options.inactiveClassName !== void 0 ? options.inactiveClassName.split(" ") : [_this.cssClassName_ + "-false"];
    var label = options.label !== void 0 ? options.label : "\u2922";
    _this.labelNode_ = typeof label === "string" ? document.createTextNode(label) : label;
    var labelActive = options.labelActive !== void 0 ? options.labelActive : "\xD7";
    _this.labelActiveNode_ = typeof labelActive === "string" ? document.createTextNode(labelActive) : labelActive;
    var tipLabel = options.tipLabel ? options.tipLabel : "Toggle full-screen";
    _this.button_ = document.createElement("button");
    _this.button_.title = tipLabel;
    _this.button_.setAttribute("type", "button");
    _this.button_.appendChild(_this.labelNode_);
    _this.button_.addEventListener(EventType_default.CLICK, _this.handleClick_.bind(_this), false);
    _this.setClassName_(_this.button_, _this.isInFullscreen_);
    _this.element.className = "".concat(_this.cssClassName_, " ").concat(CLASS_UNSELECTABLE, " ").concat(CLASS_CONTROL);
    _this.element.appendChild(_this.button_);
    return _this;
  }
  FullScreen2.prototype.handleClick_ = function(event) {
    event.preventDefault();
    this.handleFullScreen_();
  };
  FullScreen2.prototype.handleFullScreen_ = function() {
    var map = this.getMap();
    if (!map) {
      return;
    }
    var doc = map.getOwnerDocument();
    if (!isFullScreenSupported(doc)) {
      return;
    }
    if (isFullScreen(doc)) {
      exitFullScreen(doc);
    } else {
      var element = void 0;
      if (this.source_) {
        element = typeof this.source_ === "string" ? doc.getElementById(this.source_) : this.source_;
      } else {
        element = map.getTargetElement();
      }
      if (this.keys_) {
        requestFullScreenWithKeys(element);
      } else {
        requestFullScreen(element);
      }
    }
  };
  FullScreen2.prototype.handleFullScreenChange_ = function() {
    var map = this.getMap();
    if (!map) {
      return;
    }
    var wasInFullscreen = this.isInFullscreen_;
    this.isInFullscreen_ = isFullScreen(map.getOwnerDocument());
    if (wasInFullscreen !== this.isInFullscreen_) {
      this.setClassName_(this.button_, this.isInFullscreen_);
      if (this.isInFullscreen_) {
        replaceNode(this.labelActiveNode_, this.labelNode_);
        this.dispatchEvent(FullScreenEventType.ENTERFULLSCREEN);
      } else {
        replaceNode(this.labelNode_, this.labelActiveNode_);
        this.dispatchEvent(FullScreenEventType.LEAVEFULLSCREEN);
      }
      map.updateSize();
    }
  };
  FullScreen2.prototype.setClassName_ = function(element, fullscreen) {
    var _a, _b, _c, _d;
    if (fullscreen) {
      (_a = element.classList).remove.apply(_a, this.inactiveClassName_);
      (_b = element.classList).add.apply(_b, this.activeClassName_);
    } else {
      (_c = element.classList).remove.apply(_c, this.activeClassName_);
      (_d = element.classList).add.apply(_d, this.inactiveClassName_);
    }
  };
  FullScreen2.prototype.setMap = function(map) {
    var oldMap = this.getMap();
    if (oldMap) {
      oldMap.removeChangeListener(MapProperty_default.TARGET, this.boundHandleMapTargetChange_);
    }
    _super.prototype.setMap.call(this, map);
    this.handleMapTargetChange_();
    if (map) {
      map.addChangeListener(MapProperty_default.TARGET, this.boundHandleMapTargetChange_);
    }
  };
  FullScreen2.prototype.handleMapTargetChange_ = function() {
    var listeners = this.documentListeners_;
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      unlistenByKey(listeners[i]);
    }
    listeners.length = 0;
    var map = this.getMap();
    if (map) {
      var doc = map.getOwnerDocument();
      if (isFullScreenSupported(doc)) {
        this.element.classList.remove(CLASS_UNSUPPORTED);
      } else {
        this.element.classList.add(CLASS_UNSUPPORTED);
      }
      for (var i = 0, ii = events.length; i < ii; ++i) {
        listeners.push(listen(doc, events[i], this.handleFullScreenChange_, this));
      }
      this.handleFullScreenChange_();
    }
  };
  return FullScreen2;
}(Control_default);
function isFullScreenSupported(doc) {
  var body = doc.body;
  return !!(body["webkitRequestFullscreen"] || body["msRequestFullscreen"] && doc["msFullscreenEnabled"] || body.requestFullscreen && doc.fullscreenEnabled);
}
function isFullScreen(doc) {
  return !!(doc["webkitIsFullScreen"] || doc["msFullscreenElement"] || doc.fullscreenElement);
}
function requestFullScreen(element) {
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element["msRequestFullscreen"]) {
    element["msRequestFullscreen"]();
  } else if (element["webkitRequestFullscreen"]) {
    element["webkitRequestFullscreen"]();
  }
}
function requestFullScreenWithKeys(element) {
  if (element["webkitRequestFullscreen"]) {
    element["webkitRequestFullscreen"]();
  } else {
    requestFullScreen(element);
  }
}
function exitFullScreen(doc) {
  if (doc.exitFullscreen) {
    doc.exitFullscreen();
  } else if (doc["msExitFullscreen"]) {
    doc["msExitFullscreen"]();
  } else if (doc["webkitExitFullscreen"]) {
    doc["webkitExitFullscreen"]();
  }
}

// node_modules/ol/control/MousePosition.js
var __extends14 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PROJECTION = "projection";
var COORDINATE_FORMAT = "coordinateFormat";
var MousePosition = function(_super) {
  __extends14(MousePosition2, _super);
  function MousePosition2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var element = document.createElement("div");
    element.className = options.className !== void 0 ? options.className : "ol-mouse-position";
    _this = _super.call(this, {
      element,
      render: options.render,
      target: options.target
    }) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.addChangeListener(PROJECTION, _this.handleProjectionChanged_);
    if (options.coordinateFormat) {
      _this.setCoordinateFormat(options.coordinateFormat);
    }
    if (options.projection) {
      _this.setProjection(options.projection);
    }
    var renderOnMouseOut = true;
    var placeholder = "&#160;";
    if ("undefinedHTML" in options) {
      if (options.undefinedHTML !== void 0) {
        placeholder = options.undefinedHTML;
      }
      renderOnMouseOut = !!placeholder;
    } else if ("placeholder" in options) {
      if (options.placeholder === false) {
        renderOnMouseOut = false;
      } else {
        placeholder = String(options.placeholder);
      }
    }
    _this.placeholder_ = placeholder;
    _this.renderOnMouseOut_ = renderOnMouseOut;
    _this.renderedHTML_ = element.innerHTML;
    _this.mapProjection_ = null;
    _this.transform_ = null;
    return _this;
  }
  MousePosition2.prototype.handleProjectionChanged_ = function() {
    this.transform_ = null;
  };
  MousePosition2.prototype.getCoordinateFormat = function() {
    return this.get(COORDINATE_FORMAT);
  };
  MousePosition2.prototype.getProjection = function() {
    return this.get(PROJECTION);
  };
  MousePosition2.prototype.handleMouseMove = function(event) {
    var map = this.getMap();
    this.updateHTML_(map.getEventPixel(event));
  };
  MousePosition2.prototype.handleMouseOut = function(event) {
    this.updateHTML_(null);
  };
  MousePosition2.prototype.setMap = function(map) {
    _super.prototype.setMap.call(this, map);
    if (map) {
      var viewport = map.getViewport();
      this.listenerKeys.push(listen(viewport, EventType_default3.POINTERMOVE, this.handleMouseMove, this));
      if (this.renderOnMouseOut_) {
        this.listenerKeys.push(listen(viewport, EventType_default3.POINTEROUT, this.handleMouseOut, this));
      }
      this.updateHTML_(null);
    }
  };
  MousePosition2.prototype.setCoordinateFormat = function(format) {
    this.set(COORDINATE_FORMAT, format);
  };
  MousePosition2.prototype.setProjection = function(projection) {
    this.set(PROJECTION, get(projection));
  };
  MousePosition2.prototype.updateHTML_ = function(pixel) {
    var html = this.placeholder_;
    if (pixel && this.mapProjection_) {
      if (!this.transform_) {
        var projection = this.getProjection();
        if (projection) {
          this.transform_ = getTransformFromProjections(this.mapProjection_, projection);
        } else {
          this.transform_ = identityTransform;
        }
      }
      var map = this.getMap();
      var coordinate = map.getCoordinateFromPixelInternal(pixel);
      if (coordinate) {
        var userProjection = getUserProjection();
        if (userProjection) {
          this.transform_ = getTransformFromProjections(this.mapProjection_, userProjection);
        }
        this.transform_(coordinate, coordinate);
        var coordinateFormat = this.getCoordinateFormat();
        if (coordinateFormat) {
          html = coordinateFormat(coordinate);
        } else {
          html = coordinate.toString();
        }
      }
    }
    if (!this.renderedHTML_ || html !== this.renderedHTML_) {
      this.element.innerHTML = html;
      this.renderedHTML_ = html;
    }
  };
  MousePosition2.prototype.render = function(mapEvent) {
    var frameState = mapEvent.frameState;
    if (!frameState) {
      this.mapProjection_ = null;
    } else {
      if (this.mapProjection_ != frameState.viewState.projection) {
        this.mapProjection_ = frameState.viewState.projection;
        this.transform_ = null;
      }
    }
  };
  return MousePosition2;
}(Control_default);

// node_modules/ol/Overlay.js
var __extends15 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Property2 = {
  ELEMENT: "element",
  MAP: "map",
  OFFSET: "offset",
  POSITION: "position",
  POSITIONING: "positioning"
};
var Overlay = function(_super) {
  __extends15(Overlay2, _super);
  function Overlay2(options) {
    var _this = _super.call(this) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.options = options;
    _this.id = options.id;
    _this.insertFirst = options.insertFirst !== void 0 ? options.insertFirst : true;
    _this.stopEvent = options.stopEvent !== void 0 ? options.stopEvent : true;
    _this.element = document.createElement("div");
    _this.element.className = options.className !== void 0 ? options.className : "ol-overlay-container " + CLASS_SELECTABLE;
    _this.element.style.position = "absolute";
    _this.element.style.pointerEvents = "auto";
    var autoPan = options.autoPan;
    if (autoPan && "object" !== typeof autoPan) {
      autoPan = {
        animation: options.autoPanAnimation,
        margin: options.autoPanMargin
      };
    }
    _this.autoPan = autoPan || false;
    _this.rendered = {
      transform_: "",
      visible: true
    };
    _this.mapPostrenderListenerKey = null;
    _this.addChangeListener(Property2.ELEMENT, _this.handleElementChanged);
    _this.addChangeListener(Property2.MAP, _this.handleMapChanged);
    _this.addChangeListener(Property2.OFFSET, _this.handleOffsetChanged);
    _this.addChangeListener(Property2.POSITION, _this.handlePositionChanged);
    _this.addChangeListener(Property2.POSITIONING, _this.handlePositioningChanged);
    if (options.element !== void 0) {
      _this.setElement(options.element);
    }
    _this.setOffset(options.offset !== void 0 ? options.offset : [0, 0]);
    _this.setPositioning(options.positioning || "top-left");
    if (options.position !== void 0) {
      _this.setPosition(options.position);
    }
    return _this;
  }
  Overlay2.prototype.getElement = function() {
    return this.get(Property2.ELEMENT);
  };
  Overlay2.prototype.getId = function() {
    return this.id;
  };
  Overlay2.prototype.getMap = function() {
    return this.get(Property2.MAP) || null;
  };
  Overlay2.prototype.getOffset = function() {
    return this.get(Property2.OFFSET);
  };
  Overlay2.prototype.getPosition = function() {
    return this.get(Property2.POSITION);
  };
  Overlay2.prototype.getPositioning = function() {
    return this.get(Property2.POSITIONING);
  };
  Overlay2.prototype.handleElementChanged = function() {
    removeChildren(this.element);
    var element = this.getElement();
    if (element) {
      this.element.appendChild(element);
    }
  };
  Overlay2.prototype.handleMapChanged = function() {
    if (this.mapPostrenderListenerKey) {
      removeNode(this.element);
      unlistenByKey(this.mapPostrenderListenerKey);
      this.mapPostrenderListenerKey = null;
    }
    var map = this.getMap();
    if (map) {
      this.mapPostrenderListenerKey = listen(map, MapEventType_default.POSTRENDER, this.render, this);
      this.updatePixelPosition();
      var container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();
      if (this.insertFirst) {
        container.insertBefore(this.element, container.childNodes[0] || null);
      } else {
        container.appendChild(this.element);
      }
      this.performAutoPan();
    }
  };
  Overlay2.prototype.render = function() {
    this.updatePixelPosition();
  };
  Overlay2.prototype.handleOffsetChanged = function() {
    this.updatePixelPosition();
  };
  Overlay2.prototype.handlePositionChanged = function() {
    this.updatePixelPosition();
    this.performAutoPan();
  };
  Overlay2.prototype.handlePositioningChanged = function() {
    this.updatePixelPosition();
  };
  Overlay2.prototype.setElement = function(element) {
    this.set(Property2.ELEMENT, element);
  };
  Overlay2.prototype.setMap = function(map) {
    this.set(Property2.MAP, map);
  };
  Overlay2.prototype.setOffset = function(offset) {
    this.set(Property2.OFFSET, offset);
  };
  Overlay2.prototype.setPosition = function(position) {
    this.set(Property2.POSITION, position);
  };
  Overlay2.prototype.performAutoPan = function() {
    if (this.autoPan) {
      this.panIntoView(this.autoPan);
    }
  };
  Overlay2.prototype.panIntoView = function(opt_panIntoViewOptions) {
    var map = this.getMap();
    if (!map || !map.getTargetElement() || !this.get(Property2.POSITION)) {
      return;
    }
    var mapRect = this.getRect(map.getTargetElement(), map.getSize());
    var element = this.getElement();
    var overlayRect = this.getRect(element, [
      outerWidth(element),
      outerHeight(element)
    ]);
    var panIntoViewOptions = opt_panIntoViewOptions || {};
    var myMargin = panIntoViewOptions.margin === void 0 ? 20 : panIntoViewOptions.margin;
    if (!containsExtent(mapRect, overlayRect)) {
      var offsetLeft = overlayRect[0] - mapRect[0];
      var offsetRight = mapRect[2] - overlayRect[2];
      var offsetTop = overlayRect[1] - mapRect[1];
      var offsetBottom = mapRect[3] - overlayRect[3];
      var delta = [0, 0];
      if (offsetLeft < 0) {
        delta[0] = offsetLeft - myMargin;
      } else if (offsetRight < 0) {
        delta[0] = Math.abs(offsetRight) + myMargin;
      }
      if (offsetTop < 0) {
        delta[1] = offsetTop - myMargin;
      } else if (offsetBottom < 0) {
        delta[1] = Math.abs(offsetBottom) + myMargin;
      }
      if (delta[0] !== 0 || delta[1] !== 0) {
        var center = map.getView().getCenterInternal();
        var centerPx = map.getPixelFromCoordinateInternal(center);
        if (!centerPx) {
          return;
        }
        var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
        var panOptions = panIntoViewOptions.animation || {};
        map.getView().animateInternal({
          center: map.getCoordinateFromPixelInternal(newCenterPx),
          duration: panOptions.duration,
          easing: panOptions.easing
        });
      }
    }
  };
  Overlay2.prototype.getRect = function(element, size) {
    var box = element.getBoundingClientRect();
    var offsetX = box.left + window.pageXOffset;
    var offsetY = box.top + window.pageYOffset;
    return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
  };
  Overlay2.prototype.setPositioning = function(positioning) {
    this.set(Property2.POSITIONING, positioning);
  };
  Overlay2.prototype.setVisible = function(visible) {
    if (this.rendered.visible !== visible) {
      this.element.style.display = visible ? "" : "none";
      this.rendered.visible = visible;
    }
  };
  Overlay2.prototype.updatePixelPosition = function() {
    var map = this.getMap();
    var position = this.getPosition();
    if (!map || !map.isRendered() || !position) {
      this.setVisible(false);
      return;
    }
    var pixel = map.getPixelFromCoordinate(position);
    var mapSize = map.getSize();
    this.updateRenderedPosition(pixel, mapSize);
  };
  Overlay2.prototype.updateRenderedPosition = function(pixel, mapSize) {
    var style = this.element.style;
    var offset = this.getOffset();
    var positioning = this.getPositioning();
    this.setVisible(true);
    var x = Math.round(pixel[0] + offset[0]) + "px";
    var y = Math.round(pixel[1] + offset[1]) + "px";
    var posX = "0%";
    var posY = "0%";
    if (positioning == "bottom-right" || positioning == "center-right" || positioning == "top-right") {
      posX = "-100%";
    } else if (positioning == "bottom-center" || positioning == "center-center" || positioning == "top-center") {
      posX = "-50%";
    }
    if (positioning == "bottom-left" || positioning == "bottom-center" || positioning == "bottom-right") {
      posY = "-100%";
    } else if (positioning == "center-left" || positioning == "center-center" || positioning == "center-right") {
      posY = "-50%";
    }
    var transform = "translate(".concat(posX, ", ").concat(posY, ") translate(").concat(x, ", ").concat(y, ")");
    if (this.rendered.transform_ != transform) {
      this.rendered.transform_ = transform;
      style.transform = transform;
      style.msTransform = transform;
    }
  };
  Overlay2.prototype.getOptions = function() {
    return this.options;
  };
  return Overlay2;
}(Object_default);
var Overlay_default = Overlay;

// node_modules/ol/control/OverviewMap.js
var __extends16 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var MAX_RATIO = 0.75;
var MIN_RATIO = 0.1;
var ControlledMap = function(_super) {
  __extends16(ControlledMap2, _super);
  function ControlledMap2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ControlledMap2.prototype.createRenderer = function() {
    return new Composite_default(this);
  };
  return ControlledMap2;
}(PluggableMap_default);
var OverviewMap = function(_super) {
  __extends16(OverviewMap2, _super);
  function OverviewMap2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    }) || this;
    _this.boundHandleRotationChanged_ = _this.handleRotationChanged_.bind(_this);
    _this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
    _this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
    if (!_this.collapsible_) {
      _this.collapsed_ = false;
    }
    _this.rotateWithView_ = options.rotateWithView !== void 0 ? options.rotateWithView : false;
    _this.viewExtent_ = void 0;
    var className = options.className !== void 0 ? options.className : "ol-overviewmap";
    var tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Overview map";
    var collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "\u2039";
    if (typeof collapseLabel === "string") {
      _this.collapseLabel_ = document.createElement("span");
      _this.collapseLabel_.textContent = collapseLabel;
    } else {
      _this.collapseLabel_ = collapseLabel;
    }
    var label = options.label !== void 0 ? options.label : "\u203A";
    if (typeof label === "string") {
      _this.label_ = document.createElement("span");
      _this.label_.textContent = label;
    } else {
      _this.label_ = label;
    }
    var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
    var button = document.createElement("button");
    button.setAttribute("type", "button");
    button.title = tipLabel;
    button.appendChild(activeLabel);
    button.addEventListener(EventType_default.CLICK, _this.handleClick_.bind(_this), false);
    _this.ovmapDiv_ = document.createElement("div");
    _this.ovmapDiv_.className = "ol-overviewmap-map";
    _this.view_ = options.view;
    _this.ovmap_ = new ControlledMap({
      view: options.view
    });
    var ovmap = _this.ovmap_;
    if (options.layers) {
      options.layers.forEach(function(layer) {
        ovmap.addLayer(layer);
      });
    }
    var box = document.createElement("div");
    box.className = "ol-overviewmap-box";
    box.style.boxSizing = "border-box";
    _this.boxOverlay_ = new Overlay_default({
      position: [0, 0],
      positioning: "center-center",
      element: box
    });
    _this.ovmap_.addOverlay(_this.boxOverlay_);
    var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (_this.collapsible_ ? "" : " ol-uncollapsible");
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(_this.ovmapDiv_);
    element.appendChild(button);
    var scope = _this;
    var overlay = _this.boxOverlay_;
    var overlayBox = _this.boxOverlay_.getElement();
    var computeDesiredMousePosition = function(mousePosition) {
      return {
        clientX: mousePosition.clientX,
        clientY: mousePosition.clientY
      };
    };
    var move = function(event) {
      var position = computeDesiredMousePosition(event);
      var coordinates = ovmap.getEventCoordinateInternal(
        position
      );
      overlay.setPosition(coordinates);
    };
    var endMoving = function(event) {
      var coordinates = ovmap.getEventCoordinateInternal(event);
      scope.getMap().getView().setCenterInternal(coordinates);
      window.removeEventListener("mousemove", move);
      window.removeEventListener("mouseup", endMoving);
    };
    overlayBox.addEventListener("mousedown", function() {
      window.addEventListener("mousemove", move);
      window.addEventListener("mouseup", endMoving);
    });
    return _this;
  }
  OverviewMap2.prototype.setMap = function(map) {
    var oldMap = this.getMap();
    if (map === oldMap) {
      return;
    }
    if (oldMap) {
      var oldView = oldMap.getView();
      if (oldView) {
        this.unbindView_(oldView);
      }
      this.ovmap_.setTarget(null);
    }
    _super.prototype.setMap.call(this, map);
    if (map) {
      this.ovmap_.setTarget(this.ovmapDiv_);
      this.listenerKeys.push(listen(map, ObjectEventType_default.PROPERTYCHANGE, this.handleMapPropertyChange_, this));
      var view = map.getView();
      if (view) {
        this.bindView_(view);
        if (view.isDef()) {
          this.ovmap_.updateSize();
          this.resetExtent_();
        }
      }
      if (!this.ovmap_.isRendered()) {
        this.updateBoxAfterOvmapIsRendered_();
      }
    }
  };
  OverviewMap2.prototype.handleMapPropertyChange_ = function(event) {
    if (event.key === MapProperty_default.VIEW) {
      var oldView = event.oldValue;
      if (oldView) {
        this.unbindView_(oldView);
      }
      var newView = this.getMap().getView();
      this.bindView_(newView);
    } else if (!this.ovmap_.isRendered() && (event.key === MapProperty_default.TARGET || event.key === MapProperty_default.SIZE)) {
      this.ovmap_.updateSize();
    }
  };
  OverviewMap2.prototype.bindView_ = function(view) {
    if (!this.view_) {
      var newView = new View_default({
        projection: view.getProjection()
      });
      this.ovmap_.setView(newView);
    }
    view.addChangeListener(ViewProperty_default.ROTATION, this.boundHandleRotationChanged_);
    this.handleRotationChanged_();
  };
  OverviewMap2.prototype.unbindView_ = function(view) {
    view.removeChangeListener(ViewProperty_default.ROTATION, this.boundHandleRotationChanged_);
  };
  OverviewMap2.prototype.handleRotationChanged_ = function() {
    if (this.rotateWithView_) {
      this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
    }
  };
  OverviewMap2.prototype.validateExtent_ = function() {
    var map = this.getMap();
    var ovmap = this.ovmap_;
    if (!map.isRendered() || !ovmap.isRendered()) {
      return;
    }
    var mapSize = map.getSize();
    var view = map.getView();
    var extent = view.calculateExtentInternal(mapSize);
    if (this.viewExtent_ && equals2(extent, this.viewExtent_)) {
      return;
    }
    this.viewExtent_ = extent;
    var ovmapSize = ovmap.getSize();
    var ovview = ovmap.getView();
    var ovextent = ovview.calculateExtentInternal(ovmapSize);
    var topLeftPixel = ovmap.getPixelFromCoordinateInternal(getTopLeft(extent));
    var bottomRightPixel = ovmap.getPixelFromCoordinateInternal(getBottomRight(extent));
    var boxWidth = Math.abs(topLeftPixel[0] - bottomRightPixel[0]);
    var boxHeight = Math.abs(topLeftPixel[1] - bottomRightPixel[1]);
    var ovmapWidth = ovmapSize[0];
    var ovmapHeight = ovmapSize[1];
    if (boxWidth < ovmapWidth * MIN_RATIO || boxHeight < ovmapHeight * MIN_RATIO || boxWidth > ovmapWidth * MAX_RATIO || boxHeight > ovmapHeight * MAX_RATIO) {
      this.resetExtent_();
    } else if (!containsExtent(ovextent, extent)) {
      this.recenter_();
    }
  };
  OverviewMap2.prototype.resetExtent_ = function() {
    if (MAX_RATIO === 0 || MIN_RATIO === 0) {
      return;
    }
    var map = this.getMap();
    var ovmap = this.ovmap_;
    var mapSize = map.getSize();
    var view = map.getView();
    var extent = view.calculateExtentInternal(mapSize);
    var ovview = ovmap.getView();
    var steps = Math.log(MAX_RATIO / MIN_RATIO) / Math.LN2;
    var ratio = 1 / (Math.pow(2, steps / 2) * MIN_RATIO);
    scaleFromCenter(extent, ratio);
    ovview.fitInternal(fromExtent(extent));
  };
  OverviewMap2.prototype.recenter_ = function() {
    var map = this.getMap();
    var ovmap = this.ovmap_;
    var view = map.getView();
    var ovview = ovmap.getView();
    ovview.setCenterInternal(view.getCenterInternal());
  };
  OverviewMap2.prototype.updateBox_ = function() {
    var map = this.getMap();
    var ovmap = this.ovmap_;
    if (!map.isRendered() || !ovmap.isRendered()) {
      return;
    }
    var mapSize = map.getSize();
    var view = map.getView();
    var ovview = ovmap.getView();
    var rotation = this.rotateWithView_ ? 0 : -view.getRotation();
    var overlay = this.boxOverlay_;
    var box = this.boxOverlay_.getElement();
    var center = view.getCenterInternal();
    var resolution = view.getResolution();
    var ovresolution = ovview.getResolution();
    var width = mapSize[0] * resolution / ovresolution;
    var height = mapSize[1] * resolution / ovresolution;
    overlay.setPosition(center);
    if (box) {
      box.style.width = width + "px";
      box.style.height = height + "px";
      var transform = "rotate(" + rotation + "rad)";
      box.style.transform = transform;
    }
  };
  OverviewMap2.prototype.updateBoxAfterOvmapIsRendered_ = function() {
    if (this.ovmapPostrenderKey_) {
      return;
    }
    this.ovmapPostrenderKey_ = listenOnce(this.ovmap_, MapEventType_default.POSTRENDER, function(event) {
      delete this.ovmapPostrenderKey_;
      this.updateBox_();
    }, this);
  };
  OverviewMap2.prototype.handleClick_ = function(event) {
    event.preventDefault();
    this.handleToggle_();
  };
  OverviewMap2.prototype.handleToggle_ = function() {
    this.element.classList.toggle(CLASS_COLLAPSED);
    if (this.collapsed_) {
      replaceNode(this.collapseLabel_, this.label_);
    } else {
      replaceNode(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
    var ovmap = this.ovmap_;
    if (!this.collapsed_) {
      if (ovmap.isRendered()) {
        this.viewExtent_ = void 0;
        ovmap.render();
        return;
      }
      ovmap.updateSize();
      this.resetExtent_();
      this.updateBoxAfterOvmapIsRendered_();
    }
  };
  OverviewMap2.prototype.getCollapsible = function() {
    return this.collapsible_;
  };
  OverviewMap2.prototype.setCollapsible = function(collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle("ol-uncollapsible");
    if (!collapsible && this.collapsed_) {
      this.handleToggle_();
    }
  };
  OverviewMap2.prototype.setCollapsed = function(collapsed) {
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  };
  OverviewMap2.prototype.getCollapsed = function() {
    return this.collapsed_;
  };
  OverviewMap2.prototype.getRotateWithView = function() {
    return this.rotateWithView_;
  };
  OverviewMap2.prototype.setRotateWithView = function(rotateWithView) {
    if (this.rotateWithView_ === rotateWithView) {
      return;
    }
    this.rotateWithView_ = rotateWithView;
    if (this.getMap().getView().getRotation() !== 0) {
      if (this.rotateWithView_) {
        this.handleRotationChanged_();
      } else {
        this.ovmap_.getView().setRotation(0);
      }
      this.viewExtent_ = void 0;
      this.validateExtent_();
      this.updateBox_();
    }
  };
  OverviewMap2.prototype.getOverviewMap = function() {
    return this.ovmap_;
  };
  OverviewMap2.prototype.render = function(mapEvent) {
    this.validateExtent_();
    this.updateBox_();
  };
  return OverviewMap2;
}(Control_default);

// node_modules/ol/control/ScaleLine.js
var __extends17 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var UNITS_PROP = "units";
var Units = {
  DEGREES: "degrees",
  IMPERIAL: "imperial",
  NAUTICAL: "nautical",
  METRIC: "metric",
  US: "us"
};
var LEADING_DIGITS = [1, 2, 5];
var DEFAULT_DPI = 25.4 / 0.28;
var ScaleLine = function(_super) {
  __extends17(ScaleLine2, _super);
  function ScaleLine2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var className = options.className !== void 0 ? options.className : options.bar ? "ol-scale-bar" : "ol-scale-line";
    _this = _super.call(this, {
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    }) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.innerElement_ = document.createElement("div");
    _this.innerElement_.className = className + "-inner";
    _this.element.className = className + " " + CLASS_UNSELECTABLE;
    _this.element.appendChild(_this.innerElement_);
    _this.viewState_ = null;
    _this.minWidth_ = options.minWidth !== void 0 ? options.minWidth : 64;
    _this.maxWidth_ = options.maxWidth;
    _this.renderedVisible_ = false;
    _this.renderedWidth_ = void 0;
    _this.renderedHTML_ = "";
    _this.addChangeListener(UNITS_PROP, _this.handleUnitsChanged_);
    _this.setUnits(options.units || Units.METRIC);
    _this.scaleBar_ = options.bar || false;
    _this.scaleBarSteps_ = options.steps || 4;
    _this.scaleBarText_ = options.text || false;
    _this.dpi_ = options.dpi || void 0;
    return _this;
  }
  ScaleLine2.prototype.getUnits = function() {
    return this.get(UNITS_PROP);
  };
  ScaleLine2.prototype.handleUnitsChanged_ = function() {
    this.updateElement_();
  };
  ScaleLine2.prototype.setUnits = function(units) {
    this.set(UNITS_PROP, units);
  };
  ScaleLine2.prototype.setDpi = function(dpi) {
    this.dpi_ = dpi;
  };
  ScaleLine2.prototype.updateElement_ = function() {
    var viewState = this.viewState_;
    if (!viewState) {
      if (this.renderedVisible_) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    var center = viewState.center;
    var projection = viewState.projection;
    var units = this.getUnits();
    var pointResolutionUnits = units == Units.DEGREES ? Units_default.DEGREES : Units_default.METERS;
    var pointResolution = getPointResolution(projection, viewState.resolution, center, pointResolutionUnits);
    var minWidth = this.minWidth_ * (this.dpi_ || DEFAULT_DPI) / DEFAULT_DPI;
    var maxWidth = this.maxWidth_ !== void 0 ? this.maxWidth_ * (this.dpi_ || DEFAULT_DPI) / DEFAULT_DPI : void 0;
    var nominalCount = minWidth * pointResolution;
    var suffix = "";
    if (units == Units.DEGREES) {
      var metersPerDegree = METERS_PER_UNIT[Units_default.DEGREES];
      nominalCount *= metersPerDegree;
      if (nominalCount < metersPerDegree / 60) {
        suffix = "\u2033";
        pointResolution *= 3600;
      } else if (nominalCount < metersPerDegree) {
        suffix = "\u2032";
        pointResolution *= 60;
      } else {
        suffix = "\xB0";
      }
    } else if (units == Units.IMPERIAL) {
      if (nominalCount < 0.9144) {
        suffix = "in";
        pointResolution /= 0.0254;
      } else if (nominalCount < 1609.344) {
        suffix = "ft";
        pointResolution /= 0.3048;
      } else {
        suffix = "mi";
        pointResolution /= 1609.344;
      }
    } else if (units == Units.NAUTICAL) {
      pointResolution /= 1852;
      suffix = "NM";
    } else if (units == Units.METRIC) {
      if (nominalCount < 1e-3) {
        suffix = "\u03BCm";
        pointResolution *= 1e6;
      } else if (nominalCount < 1) {
        suffix = "mm";
        pointResolution *= 1e3;
      } else if (nominalCount < 1e3) {
        suffix = "m";
      } else {
        suffix = "km";
        pointResolution /= 1e3;
      }
    } else if (units == Units.US) {
      if (nominalCount < 0.9144) {
        suffix = "in";
        pointResolution *= 39.37;
      } else if (nominalCount < 1609.344) {
        suffix = "ft";
        pointResolution /= 0.30480061;
      } else {
        suffix = "mi";
        pointResolution /= 1609.3472;
      }
    } else {
      assert(false, 33);
    }
    var i = 3 * Math.floor(Math.log(minWidth * pointResolution) / Math.log(10));
    var count, width, decimalCount;
    var previousCount, previousWidth, previousDecimalCount;
    while (true) {
      decimalCount = Math.floor(i / 3);
      var decimal = Math.pow(10, decimalCount);
      count = LEADING_DIGITS[(i % 3 + 3) % 3] * decimal;
      width = Math.round(count / pointResolution);
      if (isNaN(width)) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
        return;
      }
      if (maxWidth !== void 0 && width >= maxWidth) {
        count = previousCount;
        width = previousWidth;
        decimalCount = previousDecimalCount;
        break;
      } else if (width >= minWidth) {
        break;
      }
      previousCount = count;
      previousWidth = width;
      previousDecimalCount = decimalCount;
      ++i;
    }
    var html;
    if (this.scaleBar_) {
      html = this.createScaleBar(width, count, suffix);
    } else {
      html = count.toFixed(decimalCount < 0 ? -decimalCount : 0) + " " + suffix;
    }
    if (this.renderedHTML_ != html) {
      this.innerElement_.innerHTML = html;
      this.renderedHTML_ = html;
    }
    if (this.renderedWidth_ != width) {
      this.innerElement_.style.width = width + "px";
      this.renderedWidth_ = width;
    }
    if (!this.renderedVisible_) {
      this.element.style.display = "";
      this.renderedVisible_ = true;
    }
  };
  ScaleLine2.prototype.createScaleBar = function(width, scale3, suffix) {
    var mapScale = "1 : " + Math.round(this.getScaleForResolution()).toLocaleString();
    var scaleSteps = [];
    var stepWidth = width / this.scaleBarSteps_;
    var backgroundColor = "ol-scale-singlebar-odd";
    for (var i = 0; i < this.scaleBarSteps_; i++) {
      if (i === 0) {
        scaleSteps.push(this.createMarker("absolute", i));
      }
      scaleSteps.push('<div><div class="ol-scale-singlebar ' + backgroundColor + '" style="width: ' + stepWidth + 'px;"></div>' + this.createMarker("relative", i) + (i % 2 === 0 || this.scaleBarSteps_ === 2 ? this.createStepText(i, width, false, scale3, suffix) : "") + "</div>");
      if (i === this.scaleBarSteps_ - 1) {
        {
        }
        scaleSteps.push(this.createStepText(i + 1, width, true, scale3, suffix));
      }
      backgroundColor = backgroundColor === "ol-scale-singlebar-odd" ? "ol-scale-singlebar-even" : "ol-scale-singlebar-odd";
    }
    var scaleBarText;
    if (this.scaleBarText_) {
      scaleBarText = '<div class="ol-scale-text" style="width: ' + width + 'px;">' + mapScale + "</div>";
    } else {
      scaleBarText = "";
    }
    var container = '<div style="display: flex;">' + scaleBarText + scaleSteps.join("") + "</div>";
    return container;
  };
  ScaleLine2.prototype.createMarker = function(position, i) {
    var top = position === "absolute" ? 3 : -10;
    return '<div class="ol-scale-step-marker" style="position: ' + position + ";top: " + top + 'px;"></div>';
  };
  ScaleLine2.prototype.createStepText = function(i, width, isLast, scale3, suffix) {
    var length = i === 0 ? 0 : Math.round(scale3 / this.scaleBarSteps_ * i * 100) / 100;
    var lengthString = length + (i === 0 ? "" : " " + suffix);
    var margin = i === 0 ? -3 : width / this.scaleBarSteps_ * -1;
    var minWidth = i === 0 ? 0 : width / this.scaleBarSteps_ * 2;
    return '<div class="ol-scale-step-text" style="margin-left: ' + margin + "px;text-align: " + (i === 0 ? "left" : "center") + "; min-width: " + minWidth + "px;left: " + (isLast ? width + "px" : "unset") + ';">' + lengthString + "</div>";
  };
  ScaleLine2.prototype.getScaleForResolution = function() {
    var resolution = getPointResolution(this.viewState_.projection, this.viewState_.resolution, this.viewState_.center, Units_default.METERS);
    var dpi = this.dpi_ || DEFAULT_DPI;
    var inchesPerMeter = 1e3 / 25.4;
    return parseFloat(resolution.toString()) * inchesPerMeter * dpi;
  };
  ScaleLine2.prototype.render = function(mapEvent) {
    var frameState = mapEvent.frameState;
    if (!frameState) {
      this.viewState_ = null;
    } else {
      this.viewState_ = frameState.viewState;
    }
    this.updateElement_();
  };
  return ScaleLine2;
}(Control_default);

// node_modules/ol/control/ZoomSlider.js
var __extends18 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Direction = {
  VERTICAL: 0,
  HORIZONTAL: 1
};
var ZoomSlider = function(_super) {
  __extends18(ZoomSlider2, _super);
  function ZoomSlider2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement("div"),
      render: options.render
    }) || this;
    _this.dragListenerKeys_ = [];
    _this.currentResolution_ = void 0;
    _this.direction_ = Direction.VERTICAL;
    _this.dragging_;
    _this.heightLimit_ = 0;
    _this.widthLimit_ = 0;
    _this.startX_;
    _this.startY_;
    _this.thumbSize_ = null;
    _this.sliderInitialized_ = false;
    _this.duration_ = options.duration !== void 0 ? options.duration : 200;
    var className = options.className !== void 0 ? options.className : "ol-zoomslider";
    var thumbElement = document.createElement("button");
    thumbElement.setAttribute("type", "button");
    thumbElement.className = className + "-thumb " + CLASS_UNSELECTABLE;
    var containerElement = _this.element;
    containerElement.className = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    containerElement.appendChild(thumbElement);
    containerElement.addEventListener(EventType_default3.POINTERDOWN, _this.handleDraggerStart_.bind(_this), false);
    containerElement.addEventListener(EventType_default3.POINTERMOVE, _this.handleDraggerDrag_.bind(_this), false);
    containerElement.addEventListener(EventType_default3.POINTERUP, _this.handleDraggerEnd_.bind(_this), false);
    containerElement.addEventListener(EventType_default.CLICK, _this.handleContainerClick_.bind(_this), false);
    thumbElement.addEventListener(EventType_default.CLICK, stopPropagation, false);
    return _this;
  }
  ZoomSlider2.prototype.setMap = function(map) {
    _super.prototype.setMap.call(this, map);
    if (map) {
      map.render();
    }
  };
  ZoomSlider2.prototype.initSlider_ = function() {
    var container = this.element;
    var containerWidth = container.offsetWidth;
    var containerHeight = container.offsetHeight;
    if (containerWidth === 0 && containerHeight === 0) {
      return this.sliderInitialized_ = false;
    }
    var containerStyle = getComputedStyle(container);
    containerWidth -= parseFloat(containerStyle["paddingRight"]) + parseFloat(containerStyle["paddingLeft"]);
    containerHeight -= parseFloat(containerStyle["paddingTop"]) + parseFloat(containerStyle["paddingBottom"]);
    var thumb = container.firstElementChild;
    var thumbStyle = getComputedStyle(thumb);
    var thumbWidth = thumb.offsetWidth + parseFloat(thumbStyle["marginRight"]) + parseFloat(thumbStyle["marginLeft"]);
    var thumbHeight = thumb.offsetHeight + parseFloat(thumbStyle["marginTop"]) + parseFloat(thumbStyle["marginBottom"]);
    this.thumbSize_ = [thumbWidth, thumbHeight];
    if (containerWidth > containerHeight) {
      this.direction_ = Direction.HORIZONTAL;
      this.widthLimit_ = containerWidth - thumbWidth;
    } else {
      this.direction_ = Direction.VERTICAL;
      this.heightLimit_ = containerHeight - thumbHeight;
    }
    return this.sliderInitialized_ = true;
  };
  ZoomSlider2.prototype.handleContainerClick_ = function(event) {
    var view = this.getMap().getView();
    var relativePosition = this.getRelativePosition_(event.offsetX - this.thumbSize_[0] / 2, event.offsetY - this.thumbSize_[1] / 2);
    var resolution = this.getResolutionForPosition_(relativePosition);
    var zoom = view.getConstrainedZoom(view.getZoomForResolution(resolution));
    view.animateInternal({
      zoom,
      duration: this.duration_,
      easing: easeOut
    });
  };
  ZoomSlider2.prototype.handleDraggerStart_ = function(event) {
    if (!this.dragging_ && event.target === this.element.firstElementChild) {
      var element = this.element.firstElementChild;
      this.getMap().getView().beginInteraction();
      this.startX_ = event.clientX - parseFloat(element.style.left);
      this.startY_ = event.clientY - parseFloat(element.style.top);
      this.dragging_ = true;
      if (this.dragListenerKeys_.length === 0) {
        var drag = this.handleDraggerDrag_;
        var end = this.handleDraggerEnd_;
        var doc = this.getMap().getOwnerDocument();
        this.dragListenerKeys_.push(listen(doc, EventType_default3.POINTERMOVE, drag, this), listen(doc, EventType_default3.POINTERUP, end, this));
      }
    }
  };
  ZoomSlider2.prototype.handleDraggerDrag_ = function(event) {
    if (this.dragging_) {
      var deltaX = event.clientX - this.startX_;
      var deltaY = event.clientY - this.startY_;
      var relativePosition = this.getRelativePosition_(deltaX, deltaY);
      this.currentResolution_ = this.getResolutionForPosition_(relativePosition);
      this.getMap().getView().setResolution(this.currentResolution_);
    }
  };
  ZoomSlider2.prototype.handleDraggerEnd_ = function(event) {
    if (this.dragging_) {
      var view = this.getMap().getView();
      view.endInteraction();
      this.dragging_ = false;
      this.startX_ = void 0;
      this.startY_ = void 0;
      this.dragListenerKeys_.forEach(unlistenByKey);
      this.dragListenerKeys_.length = 0;
    }
  };
  ZoomSlider2.prototype.setThumbPosition_ = function(res) {
    var position = this.getPositionForResolution_(res);
    var thumb = this.element.firstElementChild;
    if (this.direction_ == Direction.HORIZONTAL) {
      thumb.style.left = this.widthLimit_ * position + "px";
    } else {
      thumb.style.top = this.heightLimit_ * position + "px";
    }
  };
  ZoomSlider2.prototype.getRelativePosition_ = function(x, y) {
    var amount;
    if (this.direction_ === Direction.HORIZONTAL) {
      amount = x / this.widthLimit_;
    } else {
      amount = y / this.heightLimit_;
    }
    return clamp(amount, 0, 1);
  };
  ZoomSlider2.prototype.getResolutionForPosition_ = function(position) {
    var fn = this.getMap().getView().getResolutionForValueFunction();
    return fn(1 - position);
  };
  ZoomSlider2.prototype.getPositionForResolution_ = function(res) {
    var fn = this.getMap().getView().getValueForResolutionFunction();
    return clamp(1 - fn(res), 0, 1);
  };
  ZoomSlider2.prototype.render = function(mapEvent) {
    if (!mapEvent.frameState) {
      return;
    }
    if (!this.sliderInitialized_ && !this.initSlider_()) {
      return;
    }
    var res = mapEvent.frameState.viewState.resolution;
    this.currentResolution_ = res;
    this.setThumbPosition_(res);
  };
  return ZoomSlider2;
}(Control_default);

// node_modules/ol/control/ZoomToExtent.js
var __extends19 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ZoomToExtent = function(_super) {
  __extends19(ZoomToExtent2, _super);
  function ZoomToExtent2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement("div"),
      target: options.target
    }) || this;
    _this.extent = options.extent ? options.extent : null;
    var className = options.className !== void 0 ? options.className : "ol-zoom-extent";
    var label = options.label !== void 0 ? options.label : "E";
    var tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Fit to extent";
    var button = document.createElement("button");
    button.setAttribute("type", "button");
    button.title = tipLabel;
    button.appendChild(typeof label === "string" ? document.createTextNode(label) : label);
    button.addEventListener(EventType_default.CLICK, _this.handleClick_.bind(_this), false);
    var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(button);
    return _this;
  }
  ZoomToExtent2.prototype.handleClick_ = function(event) {
    event.preventDefault();
    this.handleZoomToExtent();
  };
  ZoomToExtent2.prototype.handleZoomToExtent = function() {
    var map = this.getMap();
    var view = map.getView();
    var extent = !this.extent ? view.getProjection().getExtent() : this.extent;
    view.fitInternal(fromExtent(extent));
  };
  return ZoomToExtent2;
}(Control_default);

// node_modules/ol/control.js
function defaults(opt_options) {
  var options = opt_options ? opt_options : {};
  var controls = new Collection_default();
  var zoomControl = options.zoom !== void 0 ? options.zoom : true;
  if (zoomControl) {
    controls.push(new Zoom_default(options.zoomOptions));
  }
  var rotateControl = options.rotate !== void 0 ? options.rotate : true;
  if (rotateControl) {
    controls.push(new Rotate_default(options.rotateOptions));
  }
  var attributionControl = options.attribution !== void 0 ? options.attribution : true;
  if (attributionControl) {
    controls.push(new Attribution_default(options.attributionOptions));
  }
  return controls;
}

// node_modules/ol/interaction/DoubleClickZoom.js
var __extends20 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DoubleClickZoom = function(_super) {
  __extends20(DoubleClickZoom2, _super);
  function DoubleClickZoom2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.delta_ = options.delta ? options.delta : 1;
    _this.duration_ = options.duration !== void 0 ? options.duration : 250;
    return _this;
  }
  DoubleClickZoom2.prototype.handleEvent = function(mapBrowserEvent) {
    var stopEvent = false;
    if (mapBrowserEvent.type == MapBrowserEventType_default.DBLCLICK) {
      var browserEvent = mapBrowserEvent.originalEvent;
      var map = mapBrowserEvent.map;
      var anchor = mapBrowserEvent.coordinate;
      var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
      var view = map.getView();
      zoomByDelta(view, delta, anchor, this.duration_);
      browserEvent.preventDefault();
      stopEvent = true;
    }
    return !stopEvent;
  };
  return DoubleClickZoom2;
}(Interaction_default);
var DoubleClickZoom_default = DoubleClickZoom;

// node_modules/ol/interaction/DragPan.js
var __extends21 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DragPan = function(_super) {
  __extends21(DragPan2, _super);
  function DragPan2(opt_options) {
    var _this = _super.call(this, {
      stopDown: FALSE
    }) || this;
    var options = opt_options ? opt_options : {};
    _this.kinetic_ = options.kinetic;
    _this.lastCentroid = null;
    _this.lastPointersCount_;
    _this.panning_ = false;
    var condition = options.condition ? options.condition : all(noModifierKeys, primaryAction);
    _this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;
    _this.noKinetic_ = false;
    return _this;
  }
  DragPan2.prototype.handleDragEvent = function(mapBrowserEvent) {
    if (!this.panning_) {
      this.panning_ = true;
      this.getMap().getView().beginInteraction();
    }
    var targetPointers = this.targetPointers;
    var centroid2 = centroid(targetPointers);
    if (targetPointers.length == this.lastPointersCount_) {
      if (this.kinetic_) {
        this.kinetic_.update(centroid2[0], centroid2[1]);
      }
      if (this.lastCentroid) {
        var delta = [
          this.lastCentroid[0] - centroid2[0],
          centroid2[1] - this.lastCentroid[1]
        ];
        var map = mapBrowserEvent.map;
        var view = map.getView();
        scale(delta, view.getResolution());
        rotate(delta, view.getRotation());
        view.adjustCenterInternal(delta);
      }
    } else if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = centroid2;
    this.lastPointersCount_ = targetPointers.length;
    mapBrowserEvent.originalEvent.preventDefault();
  };
  DragPan2.prototype.handleUpEvent = function(mapBrowserEvent) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        var distance2 = this.kinetic_.getDistance();
        var angle = this.kinetic_.getAngle();
        var center = view.getCenterInternal();
        var centerpx = map.getPixelFromCoordinateInternal(center);
        var dest = map.getCoordinateFromPixelInternal([
          centerpx[0] - distance2 * Math.cos(angle),
          centerpx[1] - distance2 * Math.sin(angle)
        ]);
        view.animateInternal({
          center: view.getConstrainedCenter(dest),
          duration: 500,
          easing: easeOut
        });
      }
      if (this.panning_) {
        this.panning_ = false;
        view.endInteraction();
      }
      return false;
    } else {
      if (this.kinetic_) {
        this.kinetic_.begin();
      }
      this.lastCentroid = null;
      return true;
    }
  };
  DragPan2.prototype.handleDownEvent = function(mapBrowserEvent) {
    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      this.lastCentroid = null;
      if (view.getAnimating()) {
        view.cancelAnimations();
      }
      if (this.kinetic_) {
        this.kinetic_.begin();
      }
      this.noKinetic_ = this.targetPointers.length > 1;
      return true;
    } else {
      return false;
    }
  };
  return DragPan2;
}(Pointer_default);
var DragPan_default = DragPan;

// node_modules/ol/interaction/DragRotate.js
var __extends22 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DragRotate = function(_super) {
  __extends22(DragRotate2, _super);
  function DragRotate2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      stopDown: FALSE
    }) || this;
    _this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
    _this.lastAngle_ = void 0;
    _this.duration_ = options.duration !== void 0 ? options.duration : 250;
    return _this;
  }
  DragRotate2.prototype.handleDragEvent = function(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return;
    }
    var map = mapBrowserEvent.map;
    var view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    var size = map.getSize();
    var offset = mapBrowserEvent.pixel;
    var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
    if (this.lastAngle_ !== void 0) {
      var delta = theta - this.lastAngle_;
      view.adjustRotationInternal(-delta);
    }
    this.lastAngle_ = theta;
  };
  DragRotate2.prototype.handleUpEvent = function(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return true;
    }
    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.endInteraction(this.duration_);
    return false;
  };
  DragRotate2.prototype.handleDownEvent = function(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return false;
    }
    if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
      var map = mapBrowserEvent.map;
      map.getView().beginInteraction();
      this.lastAngle_ = void 0;
      return true;
    } else {
      return false;
    }
  };
  return DragRotate2;
}(Pointer_default);
var DragRotate_default = DragRotate;

// node_modules/ol/render/Box.js
var __extends23 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RenderBox = function(_super) {
  __extends23(RenderBox2, _super);
  function RenderBox2(className) {
    var _this = _super.call(this) || this;
    _this.geometry_ = null;
    _this.element_ = document.createElement("div");
    _this.element_.style.position = "absolute";
    _this.element_.style.pointerEvents = "auto";
    _this.element_.className = "ol-box " + className;
    _this.map_ = null;
    _this.startPixel_ = null;
    _this.endPixel_ = null;
    return _this;
  }
  RenderBox2.prototype.disposeInternal = function() {
    this.setMap(null);
  };
  RenderBox2.prototype.render_ = function() {
    var startPixel = this.startPixel_;
    var endPixel = this.endPixel_;
    var px = "px";
    var style = this.element_.style;
    style.left = Math.min(startPixel[0], endPixel[0]) + px;
    style.top = Math.min(startPixel[1], endPixel[1]) + px;
    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
  };
  RenderBox2.prototype.setMap = function(map) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      var style = this.element_.style;
      style.left = "inherit";
      style.top = "inherit";
      style.width = "inherit";
      style.height = "inherit";
    }
    this.map_ = map;
    if (this.map_) {
      this.map_.getOverlayContainer().appendChild(this.element_);
    }
  };
  RenderBox2.prototype.setPixels = function(startPixel, endPixel) {
    this.startPixel_ = startPixel;
    this.endPixel_ = endPixel;
    this.createOrUpdateGeometry();
    this.render_();
  };
  RenderBox2.prototype.createOrUpdateGeometry = function() {
    var startPixel = this.startPixel_;
    var endPixel = this.endPixel_;
    var pixels = [
      startPixel,
      [startPixel[0], endPixel[1]],
      endPixel,
      [endPixel[0], startPixel[1]]
    ];
    var coordinates = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_);
    coordinates[4] = coordinates[0].slice();
    if (!this.geometry_) {
      this.geometry_ = new Polygon_default([coordinates]);
    } else {
      this.geometry_.setCoordinates([coordinates]);
    }
  };
  RenderBox2.prototype.getGeometry = function() {
    return this.geometry_;
  };
  return RenderBox2;
}(Disposable_default);
var Box_default = RenderBox;

// node_modules/ol/interaction/DragBox.js
var __extends24 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DragBoxEventType = {
  BOXSTART: "boxstart",
  BOXDRAG: "boxdrag",
  BOXEND: "boxend",
  BOXCANCEL: "boxcancel"
};
var DragBoxEvent = function(_super) {
  __extends24(DragBoxEvent2, _super);
  function DragBoxEvent2(type, coordinate, mapBrowserEvent) {
    var _this = _super.call(this, type) || this;
    _this.coordinate = coordinate;
    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }
  return DragBoxEvent2;
}(Event_default);
var DragBox = function(_super) {
  __extends24(DragBox2, _super);
  function DragBox2(opt_options) {
    var _this = _super.call(this) || this;
    _this.on;
    _this.once;
    _this.un;
    var options = opt_options ? opt_options : {};
    _this.box_ = new Box_default(options.className || "ol-dragbox");
    _this.minArea_ = options.minArea !== void 0 ? options.minArea : 64;
    if (options.onBoxEnd) {
      _this.onBoxEnd = options.onBoxEnd;
    }
    _this.startPixel_ = null;
    _this.condition_ = options.condition ? options.condition : mouseActionButton;
    _this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : _this.defaultBoxEndCondition;
    return _this;
  }
  DragBox2.prototype.defaultBoxEndCondition = function(mapBrowserEvent, startPixel, endPixel) {
    var width = endPixel[0] - startPixel[0];
    var height = endPixel[1] - startPixel[1];
    return width * width + height * height >= this.minArea_;
  };
  DragBox2.prototype.getGeometry = function() {
    return this.box_.getGeometry();
  };
  DragBox2.prototype.handleDragEvent = function(mapBrowserEvent) {
    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
  };
  DragBox2.prototype.handleUpEvent = function(mapBrowserEvent) {
    this.box_.setMap(null);
    var completeBox = this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel);
    if (completeBox) {
      this.onBoxEnd(mapBrowserEvent);
    }
    this.dispatchEvent(new DragBoxEvent(completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL, mapBrowserEvent.coordinate, mapBrowserEvent));
    return false;
  };
  DragBox2.prototype.handleDownEvent = function(mapBrowserEvent) {
    if (this.condition_(mapBrowserEvent)) {
      this.startPixel_ = mapBrowserEvent.pixel;
      this.box_.setMap(mapBrowserEvent.map);
      this.box_.setPixels(this.startPixel_, this.startPixel_);
      this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
      return true;
    } else {
      return false;
    }
  };
  DragBox2.prototype.onBoxEnd = function(event) {
  };
  return DragBox2;
}(Pointer_default);
var DragBox_default = DragBox;

// node_modules/ol/interaction/DragZoom.js
var __extends25 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DragZoom = function(_super) {
  __extends25(DragZoom2, _super);
  function DragZoom2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var condition = options.condition ? options.condition : shiftKeyOnly;
    _this = _super.call(this, {
      condition,
      className: options.className || "ol-dragzoom",
      minArea: options.minArea
    }) || this;
    _this.duration_ = options.duration !== void 0 ? options.duration : 200;
    _this.out_ = options.out !== void 0 ? options.out : false;
    return _this;
  }
  DragZoom2.prototype.onBoxEnd = function(event) {
    var map = this.getMap();
    var view = map.getView();
    var geometry = this.getGeometry();
    if (this.out_) {
      var rotatedExtent = view.rotatedExtentForGeometry(geometry);
      var resolution = view.getResolutionForExtentInternal(rotatedExtent);
      var factor = view.getResolution() / resolution;
      geometry = geometry.clone();
      geometry.scale(factor * factor);
    }
    view.fitInternal(geometry, {
      duration: this.duration_,
      easing: easeOut
    });
  };
  return DragZoom2;
}(DragBox_default);
var DragZoom_default = DragZoom;

// node_modules/ol/events/KeyCode.js
var KeyCode_default = {
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
};

// node_modules/ol/interaction/KeyboardPan.js
var __extends26 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var KeyboardPan = function(_super) {
  __extends26(KeyboardPan2, _super);
  function KeyboardPan2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options || {};
    _this.defaultCondition_ = function(mapBrowserEvent) {
      return noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
    };
    _this.condition_ = options.condition !== void 0 ? options.condition : _this.defaultCondition_;
    _this.duration_ = options.duration !== void 0 ? options.duration : 100;
    _this.pixelDelta_ = options.pixelDelta !== void 0 ? options.pixelDelta : 128;
    return _this;
  }
  KeyboardPan2.prototype.handleEvent = function(mapBrowserEvent) {
    var stopEvent = false;
    if (mapBrowserEvent.type == EventType_default.KEYDOWN) {
      var keyEvent = mapBrowserEvent.originalEvent;
      var keyCode = keyEvent.keyCode;
      if (this.condition_(mapBrowserEvent) && (keyCode == KeyCode_default.DOWN || keyCode == KeyCode_default.LEFT || keyCode == KeyCode_default.RIGHT || keyCode == KeyCode_default.UP)) {
        var map = mapBrowserEvent.map;
        var view = map.getView();
        var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
        var deltaX = 0, deltaY = 0;
        if (keyCode == KeyCode_default.DOWN) {
          deltaY = -mapUnitsDelta;
        } else if (keyCode == KeyCode_default.LEFT) {
          deltaX = -mapUnitsDelta;
        } else if (keyCode == KeyCode_default.RIGHT) {
          deltaX = mapUnitsDelta;
        } else {
          deltaY = mapUnitsDelta;
        }
        var delta = [deltaX, deltaY];
        rotate(delta, view.getRotation());
        pan(view, delta, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  };
  return KeyboardPan2;
}(Interaction_default);
var KeyboardPan_default = KeyboardPan;

// node_modules/ol/interaction/KeyboardZoom.js
var __extends27 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var KeyboardZoom = function(_super) {
  __extends27(KeyboardZoom2, _super);
  function KeyboardZoom2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.condition_ = options.condition ? options.condition : targetNotEditable;
    _this.delta_ = options.delta ? options.delta : 1;
    _this.duration_ = options.duration !== void 0 ? options.duration : 100;
    return _this;
  }
  KeyboardZoom2.prototype.handleEvent = function(mapBrowserEvent) {
    var stopEvent = false;
    if (mapBrowserEvent.type == EventType_default.KEYDOWN || mapBrowserEvent.type == EventType_default.KEYPRESS) {
      var keyEvent = mapBrowserEvent.originalEvent;
      var charCode = keyEvent.charCode;
      if (this.condition_(mapBrowserEvent) && (charCode == "+".charCodeAt(0) || charCode == "-".charCodeAt(0))) {
        var map = mapBrowserEvent.map;
        var delta = charCode == "+".charCodeAt(0) ? this.delta_ : -this.delta_;
        var view = map.getView();
        zoomByDelta(view, delta, void 0, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  };
  return KeyboardZoom2;
}(Interaction_default);
var KeyboardZoom_default = KeyboardZoom;

// node_modules/ol/interaction/MouseWheelZoom.js
var __extends28 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Mode = {
  TRACKPAD: "trackpad",
  WHEEL: "wheel"
};
var MouseWheelZoom = function(_super) {
  __extends28(MouseWheelZoom2, _super);
  function MouseWheelZoom2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(
      this,
      options
    ) || this;
    _this.totalDelta_ = 0;
    _this.lastDelta_ = 0;
    _this.maxDelta_ = options.maxDelta !== void 0 ? options.maxDelta : 1;
    _this.duration_ = options.duration !== void 0 ? options.duration : 250;
    _this.timeout_ = options.timeout !== void 0 ? options.timeout : 80;
    _this.useAnchor_ = options.useAnchor !== void 0 ? options.useAnchor : true;
    _this.constrainResolution_ = options.constrainResolution !== void 0 ? options.constrainResolution : false;
    var condition = options.condition ? options.condition : always;
    _this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;
    _this.lastAnchor_ = null;
    _this.startTime_ = void 0;
    _this.timeoutId_;
    _this.mode_ = void 0;
    _this.trackpadEventGap_ = 400;
    _this.trackpadTimeoutId_;
    _this.deltaPerZoom_ = 300;
    return _this;
  }
  MouseWheelZoom2.prototype.endInteraction_ = function() {
    this.trackpadTimeoutId_ = void 0;
    var map = this.getMap();
    if (!map) {
      return;
    }
    var view = map.getView();
    view.endInteraction(void 0, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_);
  };
  MouseWheelZoom2.prototype.handleEvent = function(mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }
    var type = mapBrowserEvent.type;
    if (type !== EventType_default.WHEEL) {
      return true;
    }
    var map = mapBrowserEvent.map;
    var wheelEvent = mapBrowserEvent.originalEvent;
    wheelEvent.preventDefault();
    if (this.useAnchor_) {
      this.lastAnchor_ = mapBrowserEvent.coordinate;
    }
    var delta;
    if (mapBrowserEvent.type == EventType_default.WHEEL) {
      delta = wheelEvent.deltaY;
      if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
        delta /= DEVICE_PIXEL_RATIO;
      }
      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
        delta *= 40;
      }
    }
    if (delta === 0) {
      return false;
    } else {
      this.lastDelta_ = delta;
    }
    var now = Date.now();
    if (this.startTime_ === void 0) {
      this.startTime_ = now;
    }
    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
      this.mode_ = Math.abs(delta) < 4 ? Mode.TRACKPAD : Mode.WHEEL;
    }
    var view = map.getView();
    if (this.mode_ === Mode.TRACKPAD && !(view.getConstrainResolution() || this.constrainResolution_)) {
      if (this.trackpadTimeoutId_) {
        clearTimeout(this.trackpadTimeoutId_);
      } else {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.beginInteraction();
      }
      this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
      view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
      this.startTime_ = now;
      return false;
    }
    this.totalDelta_ += delta;
    var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
    clearTimeout(this.timeoutId_);
    this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
    return false;
  };
  MouseWheelZoom2.prototype.handleWheelZoom_ = function(map) {
    var view = map.getView();
    if (view.getAnimating()) {
      view.cancelAnimations();
    }
    var delta = -clamp(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
    if (view.getConstrainResolution() || this.constrainResolution_) {
      delta = delta ? delta > 0 ? 1 : -1 : 0;
    }
    zoomByDelta(view, delta, this.lastAnchor_, this.duration_);
    this.mode_ = void 0;
    this.totalDelta_ = 0;
    this.lastAnchor_ = null;
    this.startTime_ = void 0;
    this.timeoutId_ = void 0;
  };
  MouseWheelZoom2.prototype.setMouseAnchor = function(useAnchor) {
    this.useAnchor_ = useAnchor;
    if (!useAnchor) {
      this.lastAnchor_ = null;
    }
  };
  return MouseWheelZoom2;
}(Interaction_default);
var MouseWheelZoom_default = MouseWheelZoom;

// node_modules/ol/interaction/PinchRotate.js
var __extends29 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PinchRotate = function(_super) {
  __extends29(PinchRotate2, _super);
  function PinchRotate2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var pointerOptions = options;
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    _this = _super.call(this, pointerOptions) || this;
    _this.anchor_ = null;
    _this.lastAngle_ = void 0;
    _this.rotating_ = false;
    _this.rotationDelta_ = 0;
    _this.threshold_ = options.threshold !== void 0 ? options.threshold : 0.3;
    _this.duration_ = options.duration !== void 0 ? options.duration : 250;
    return _this;
  }
  PinchRotate2.prototype.handleDragEvent = function(mapBrowserEvent) {
    var rotationDelta = 0;
    var touch0 = this.targetPointers[0];
    var touch1 = this.targetPointers[1];
    var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);
    if (this.lastAngle_ !== void 0) {
      var delta = angle - this.lastAngle_;
      this.rotationDelta_ += delta;
      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
        this.rotating_ = true;
      }
      rotationDelta = delta;
    }
    this.lastAngle_ = angle;
    var map = mapBrowserEvent.map;
    var view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    var viewportPosition = map.getViewport().getBoundingClientRect();
    var centroid2 = centroid(this.targetPointers);
    centroid2[0] -= viewportPosition.left;
    centroid2[1] -= viewportPosition.top;
    this.anchor_ = map.getCoordinateFromPixelInternal(centroid2);
    if (this.rotating_) {
      map.render();
      view.adjustRotationInternal(rotationDelta, this.anchor_);
    }
  };
  PinchRotate2.prototype.handleUpEvent = function(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      view.endInteraction(this.duration_);
      return false;
    } else {
      return true;
    }
  };
  PinchRotate2.prototype.handleDownEvent = function(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      var map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastAngle_ = void 0;
      this.rotating_ = false;
      this.rotationDelta_ = 0;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    } else {
      return false;
    }
  };
  return PinchRotate2;
}(Pointer_default);
var PinchRotate_default = PinchRotate;

// node_modules/ol/interaction/PinchZoom.js
var __extends30 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PinchZoom = function(_super) {
  __extends30(PinchZoom2, _super);
  function PinchZoom2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var pointerOptions = options;
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    _this = _super.call(this, pointerOptions) || this;
    _this.anchor_ = null;
    _this.duration_ = options.duration !== void 0 ? options.duration : 400;
    _this.lastDistance_ = void 0;
    _this.lastScaleDelta_ = 1;
    return _this;
  }
  PinchZoom2.prototype.handleDragEvent = function(mapBrowserEvent) {
    var scaleDelta = 1;
    var touch0 = this.targetPointers[0];
    var touch1 = this.targetPointers[1];
    var dx = touch0.clientX - touch1.clientX;
    var dy = touch0.clientY - touch1.clientY;
    var distance2 = Math.sqrt(dx * dx + dy * dy);
    if (this.lastDistance_ !== void 0) {
      scaleDelta = this.lastDistance_ / distance2;
    }
    this.lastDistance_ = distance2;
    var map = mapBrowserEvent.map;
    var view = map.getView();
    if (scaleDelta != 1) {
      this.lastScaleDelta_ = scaleDelta;
    }
    var viewportPosition = map.getViewport().getBoundingClientRect();
    var centroid2 = centroid(this.targetPointers);
    centroid2[0] -= viewportPosition.left;
    centroid2[1] -= viewportPosition.top;
    this.anchor_ = map.getCoordinateFromPixelInternal(centroid2);
    map.render();
    view.adjustResolutionInternal(scaleDelta, this.anchor_);
  };
  PinchZoom2.prototype.handleUpEvent = function(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
      view.endInteraction(this.duration_, direction);
      return false;
    } else {
      return true;
    }
  };
  PinchZoom2.prototype.handleDownEvent = function(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      var map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastDistance_ = void 0;
      this.lastScaleDelta_ = 1;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    } else {
      return false;
    }
  };
  return PinchZoom2;
}(Pointer_default);
var PinchZoom_default = PinchZoom;

// node_modules/ol/interaction/DragAndDrop.js
var __extends31 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DragAndDropEventType = {
  ADD_FEATURES: "addfeatures"
};
var DragAndDropEvent = function(_super) {
  __extends31(DragAndDropEvent2, _super);
  function DragAndDropEvent2(type, file, opt_features, opt_projection) {
    var _this = _super.call(this, type) || this;
    _this.features = opt_features;
    _this.file = file;
    _this.projection = opt_projection;
    return _this;
  }
  return DragAndDropEvent2;
}(Event_default);
var DragAndDrop = function(_super) {
  __extends31(DragAndDrop2, _super);
  function DragAndDrop2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      handleEvent: TRUE
    }) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.readAsBuffer_ = false;
    _this.formats_ = [];
    var formatConstructors = options.formatConstructors ? options.formatConstructors : [];
    for (var i = 0, ii = formatConstructors.length; i < ii; ++i) {
      var format = formatConstructors[i];
      if (typeof format === "function") {
        format = new format();
      }
      _this.formats_.push(format);
      _this.readAsBuffer_ = _this.readAsBuffer_ || format.getType() === "arraybuffer";
    }
    _this.projection_ = options.projection ? get(options.projection) : null;
    _this.dropListenKeys_ = null;
    _this.source_ = options.source || null;
    _this.target = options.target ? options.target : null;
    return _this;
  }
  DragAndDrop2.prototype.handleResult_ = function(file, event) {
    var result = event.target.result;
    var map = this.getMap();
    var projection = this.projection_;
    if (!projection) {
      var view = map.getView();
      projection = view.getProjection();
    }
    var text;
    var formats = this.formats_;
    for (var i = 0, ii = formats.length; i < ii; ++i) {
      var format = formats[i];
      var input = result;
      if (this.readAsBuffer_ && format.getType() !== "arraybuffer") {
        if (text === void 0) {
          text = new TextDecoder().decode(result);
        }
        input = text;
      }
      var features = this.tryReadFeatures_(format, input, {
        featureProjection: projection
      });
      if (features && features.length > 0) {
        if (this.source_) {
          this.source_.clear();
          this.source_.addFeatures(features);
        }
        this.dispatchEvent(new DragAndDropEvent(DragAndDropEventType.ADD_FEATURES, file, features, projection));
        break;
      }
    }
  };
  DragAndDrop2.prototype.registerListeners_ = function() {
    var map = this.getMap();
    if (map) {
      var dropArea = this.target ? this.target : map.getViewport();
      this.dropListenKeys_ = [
        listen(dropArea, EventType_default.DROP, this.handleDrop, this),
        listen(dropArea, EventType_default.DRAGENTER, this.handleStop, this),
        listen(dropArea, EventType_default.DRAGOVER, this.handleStop, this),
        listen(dropArea, EventType_default.DROP, this.handleStop, this)
      ];
    }
  };
  DragAndDrop2.prototype.setActive = function(active) {
    if (!this.getActive() && active) {
      this.registerListeners_();
    }
    if (this.getActive() && !active) {
      this.unregisterListeners_();
    }
    _super.prototype.setActive.call(this, active);
  };
  DragAndDrop2.prototype.setMap = function(map) {
    this.unregisterListeners_();
    _super.prototype.setMap.call(this, map);
    if (this.getActive()) {
      this.registerListeners_();
    }
  };
  DragAndDrop2.prototype.tryReadFeatures_ = function(format, text, options) {
    try {
      return format.readFeatures(text, options);
    } catch (e) {
      return null;
    }
  };
  DragAndDrop2.prototype.unregisterListeners_ = function() {
    if (this.dropListenKeys_) {
      this.dropListenKeys_.forEach(unlistenByKey);
      this.dropListenKeys_ = null;
    }
  };
  DragAndDrop2.prototype.handleDrop = function(event) {
    var files = event.dataTransfer.files;
    for (var i = 0, ii = files.length; i < ii; ++i) {
      var file = files.item(i);
      var reader = new FileReader();
      reader.addEventListener(EventType_default.LOAD, this.handleResult_.bind(this, file));
      if (this.readAsBuffer_) {
        reader.readAsArrayBuffer(file);
      } else {
        reader.readAsText(file);
      }
    }
  };
  DragAndDrop2.prototype.handleStop = function(event) {
    event.stopPropagation();
    event.preventDefault();
    event.dataTransfer.dropEffect = "copy";
  };
  return DragAndDrop2;
}(Interaction_default);

// node_modules/ol/interaction/DragRotateAndZoom.js
var __extends32 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DragRotateAndZoom = function(_super) {
  __extends32(DragRotateAndZoom2, _super);
  function DragRotateAndZoom2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, options) || this;
    _this.condition_ = options.condition ? options.condition : shiftKeyOnly;
    _this.lastAngle_ = void 0;
    _this.lastMagnitude_ = void 0;
    _this.lastScaleDelta_ = 0;
    _this.duration_ = options.duration !== void 0 ? options.duration : 400;
    return _this;
  }
  DragRotateAndZoom2.prototype.handleDragEvent = function(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return;
    }
    var map = mapBrowserEvent.map;
    var size = map.getSize();
    var offset = mapBrowserEvent.pixel;
    var deltaX = offset[0] - size[0] / 2;
    var deltaY = size[1] / 2 - offset[1];
    var theta = Math.atan2(deltaY, deltaX);
    var magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    var view = map.getView();
    if (this.lastAngle_ !== void 0) {
      var angleDelta = this.lastAngle_ - theta;
      view.adjustRotationInternal(angleDelta);
    }
    this.lastAngle_ = theta;
    if (this.lastMagnitude_ !== void 0) {
      view.adjustResolutionInternal(this.lastMagnitude_ / magnitude);
    }
    if (this.lastMagnitude_ !== void 0) {
      this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;
    }
    this.lastMagnitude_ = magnitude;
  };
  DragRotateAndZoom2.prototype.handleUpEvent = function(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return true;
    }
    var map = mapBrowserEvent.map;
    var view = map.getView();
    var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
    view.endInteraction(this.duration_, direction);
    this.lastScaleDelta_ = 0;
    return false;
  };
  DragRotateAndZoom2.prototype.handleDownEvent = function(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return false;
    }
    if (this.condition_(mapBrowserEvent)) {
      mapBrowserEvent.map.getView().beginInteraction();
      this.lastAngle_ = void 0;
      this.lastMagnitude_ = void 0;
      return true;
    } else {
      return false;
    }
  };
  return DragRotateAndZoom2;
}(Pointer_default);

// node_modules/ol/interaction/Extent.js
var __extends33 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ExtentEventType = {
  EXTENTCHANGED: "extentchanged"
};
var ExtentEvent = function(_super) {
  __extends33(ExtentEvent2, _super);
  function ExtentEvent2(extent) {
    var _this = _super.call(this, ExtentEventType.EXTENTCHANGED) || this;
    _this.extent = extent;
    return _this;
  }
  return ExtentEvent2;
}(Event_default);
var Extent = function(_super) {
  __extends33(Extent2, _super);
  function Extent2(opt_options) {
    var _this = this;
    var options = opt_options || {};
    _this = _super.call(this, options) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.condition_ = options.condition ? options.condition : always;
    _this.extent_ = null;
    _this.pointerHandler_ = null;
    _this.pixelTolerance_ = options.pixelTolerance !== void 0 ? options.pixelTolerance : 10;
    _this.snappedToVertex_ = false;
    _this.extentFeature_ = null;
    _this.vertexFeature_ = null;
    if (!opt_options) {
      opt_options = {};
    }
    _this.extentOverlay_ = new Vector_default({
      source: new Vector_default2({
        useSpatialIndex: false,
        wrapX: !!opt_options.wrapX
      }),
      style: opt_options.boxStyle ? opt_options.boxStyle : getDefaultExtentStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });
    _this.vertexOverlay_ = new Vector_default({
      source: new Vector_default2({
        useSpatialIndex: false,
        wrapX: !!opt_options.wrapX
      }),
      style: opt_options.pointerStyle ? opt_options.pointerStyle : getDefaultPointerStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });
    if (opt_options.extent) {
      _this.setExtent(opt_options.extent);
    }
    return _this;
  }
  Extent2.prototype.snapToVertex_ = function(pixel, map) {
    var pixelCoordinate = map.getCoordinateFromPixelInternal(pixel);
    var sortByDistance = function(a, b) {
      return squaredDistanceToSegment(pixelCoordinate, a) - squaredDistanceToSegment(pixelCoordinate, b);
    };
    var extent = this.getExtentInternal();
    if (extent) {
      var segments = getSegments(extent);
      segments.sort(sortByDistance);
      var closestSegment = segments[0];
      var vertex = closestOnSegment(pixelCoordinate, closestSegment);
      var vertexPixel = map.getPixelFromCoordinateInternal(vertex);
      if (distance(pixel, vertexPixel) <= this.pixelTolerance_) {
        var pixel1 = map.getPixelFromCoordinateInternal(closestSegment[0]);
        var pixel2 = map.getPixelFromCoordinateInternal(closestSegment[1]);
        var squaredDist1 = squaredDistance(vertexPixel, pixel1);
        var squaredDist2 = squaredDistance(vertexPixel, pixel2);
        var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
        this.snappedToVertex_ = dist <= this.pixelTolerance_;
        if (this.snappedToVertex_) {
          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
        }
        return vertex;
      }
    }
    return null;
  };
  Extent2.prototype.handlePointerMove_ = function(mapBrowserEvent) {
    var pixel = mapBrowserEvent.pixel;
    var map = mapBrowserEvent.map;
    var vertex = this.snapToVertex_(pixel, map);
    if (!vertex) {
      vertex = map.getCoordinateFromPixelInternal(pixel);
    }
    this.createOrUpdatePointerFeature_(vertex);
  };
  Extent2.prototype.createOrUpdateExtentFeature_ = function(extent) {
    var extentFeature = this.extentFeature_;
    if (!extentFeature) {
      if (!extent) {
        extentFeature = new Feature_default({});
      } else {
        extentFeature = new Feature_default(fromExtent(extent));
      }
      this.extentFeature_ = extentFeature;
      this.extentOverlay_.getSource().addFeature(extentFeature);
    } else {
      if (!extent) {
        extentFeature.setGeometry(void 0);
      } else {
        extentFeature.setGeometry(fromExtent(extent));
      }
    }
    return extentFeature;
  };
  Extent2.prototype.createOrUpdatePointerFeature_ = function(vertex) {
    var vertexFeature = this.vertexFeature_;
    if (!vertexFeature) {
      vertexFeature = new Feature_default(new Point_default(vertex));
      this.vertexFeature_ = vertexFeature;
      this.vertexOverlay_.getSource().addFeature(vertexFeature);
    } else {
      var geometry = vertexFeature.getGeometry();
      geometry.setCoordinates(vertex);
    }
    return vertexFeature;
  };
  Extent2.prototype.handleEvent = function(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent || !this.condition_(mapBrowserEvent)) {
      return true;
    }
    if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERMOVE && !this.handlingDownUpSequence) {
      this.handlePointerMove_(mapBrowserEvent);
    }
    _super.prototype.handleEvent.call(this, mapBrowserEvent);
    return false;
  };
  Extent2.prototype.handleDownEvent = function(mapBrowserEvent) {
    var pixel = mapBrowserEvent.pixel;
    var map = mapBrowserEvent.map;
    var extent = this.getExtentInternal();
    var vertex = this.snapToVertex_(pixel, map);
    var getOpposingPoint = function(point) {
      var x_ = null;
      var y_ = null;
      if (point[0] == extent[0]) {
        x_ = extent[2];
      } else if (point[0] == extent[2]) {
        x_ = extent[0];
      }
      if (point[1] == extent[1]) {
        y_ = extent[3];
      } else if (point[1] == extent[3]) {
        y_ = extent[1];
      }
      if (x_ !== null && y_ !== null) {
        return [x_, y_];
      }
      return null;
    };
    if (vertex && extent) {
      var x = vertex[0] == extent[0] || vertex[0] == extent[2] ? vertex[0] : null;
      var y = vertex[1] == extent[1] || vertex[1] == extent[3] ? vertex[1] : null;
      if (x !== null && y !== null) {
        this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex));
      } else if (x !== null) {
        this.pointerHandler_ = getEdgeHandler(getOpposingPoint([x, extent[1]]), getOpposingPoint([x, extent[3]]));
      } else if (y !== null) {
        this.pointerHandler_ = getEdgeHandler(getOpposingPoint([extent[0], y]), getOpposingPoint([extent[2], y]));
      }
    } else {
      vertex = map.getCoordinateFromPixelInternal(pixel);
      this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);
      this.pointerHandler_ = getPointHandler(vertex);
    }
    return true;
  };
  Extent2.prototype.handleDragEvent = function(mapBrowserEvent) {
    if (this.pointerHandler_) {
      var pixelCoordinate = mapBrowserEvent.coordinate;
      this.setExtent(this.pointerHandler_(pixelCoordinate));
      this.createOrUpdatePointerFeature_(pixelCoordinate);
    }
  };
  Extent2.prototype.handleUpEvent = function(mapBrowserEvent) {
    this.pointerHandler_ = null;
    var extent = this.getExtentInternal();
    if (!extent || getArea(extent) === 0) {
      this.setExtent(null);
    }
    return false;
  };
  Extent2.prototype.setMap = function(map) {
    this.extentOverlay_.setMap(map);
    this.vertexOverlay_.setMap(map);
    _super.prototype.setMap.call(this, map);
  };
  Extent2.prototype.getExtent = function() {
    return toUserExtent(this.getExtentInternal(), this.getMap().getView().getProjection());
  };
  Extent2.prototype.getExtentInternal = function() {
    return this.extent_;
  };
  Extent2.prototype.setExtent = function(extent) {
    this.extent_ = extent ? extent : null;
    this.createOrUpdateExtentFeature_(extent);
    this.dispatchEvent(new ExtentEvent(this.extent_));
  };
  return Extent2;
}(Pointer_default);
function getDefaultExtentStyleFunction() {
  var style = createEditingStyle();
  return function(feature, resolution) {
    return style["Polygon"];
  };
}
function getDefaultPointerStyleFunction() {
  var style = createEditingStyle();
  return function(feature, resolution) {
    return style["Point"];
  };
}
function getPointHandler(fixedPoint) {
  return function(point) {
    return boundingExtent([fixedPoint, point]);
  };
}
function getEdgeHandler(fixedP1, fixedP2) {
  if (fixedP1[0] == fixedP2[0]) {
    return function(point) {
      return boundingExtent([fixedP1, [point[0], fixedP2[1]]]);
    };
  } else if (fixedP1[1] == fixedP2[1]) {
    return function(point) {
      return boundingExtent([fixedP1, [fixedP2[0], point[1]]]);
    };
  } else {
    return null;
  }
}
function getSegments(extent) {
  return [
    [
      [extent[0], extent[1]],
      [extent[0], extent[3]]
    ],
    [
      [extent[0], extent[3]],
      [extent[2], extent[3]]
    ],
    [
      [extent[2], extent[3]],
      [extent[2], extent[1]]
    ],
    [
      [extent[2], extent[1]],
      [extent[0], extent[1]]
    ]
  ];
}

// node_modules/ol/interaction/Modify.js
var __extends34 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CIRCLE_CENTER_INDEX = 0;
var CIRCLE_CIRCUMFERENCE_INDEX = 1;
var tempExtent = [0, 0, 0, 0];
var tempSegment = [];
var ModifyEventType = {
  MODIFYSTART: "modifystart",
  MODIFYEND: "modifyend"
};
var ModifyEvent = function(_super) {
  __extends34(ModifyEvent2, _super);
  function ModifyEvent2(type, features, mapBrowserEvent) {
    var _this = _super.call(this, type) || this;
    _this.features = features;
    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }
  return ModifyEvent2;
}(Event_default);
var Modify = function(_super) {
  __extends34(Modify2, _super);
  function Modify2(options) {
    var _this = _super.call(this, options) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.boundHandleFeatureChange_ = _this.handleFeatureChange_.bind(_this);
    _this.condition_ = options.condition ? options.condition : primaryAction;
    _this.defaultDeleteCondition_ = function(mapBrowserEvent) {
      return altKeyOnly(mapBrowserEvent) && singleClick(mapBrowserEvent);
    };
    _this.deleteCondition_ = options.deleteCondition ? options.deleteCondition : _this.defaultDeleteCondition_;
    _this.insertVertexCondition_ = options.insertVertexCondition ? options.insertVertexCondition : always;
    _this.vertexFeature_ = null;
    _this.vertexSegments_ = null;
    _this.lastPixel_ = [0, 0];
    _this.ignoreNextSingleClick_ = false;
    _this.featuresBeingModified_ = null;
    _this.rBush_ = new RBush_default();
    _this.pixelTolerance_ = options.pixelTolerance !== void 0 ? options.pixelTolerance : 10;
    _this.snappedToVertex_ = false;
    _this.changingFeature_ = false;
    _this.dragSegments_ = [];
    _this.overlay_ = new Vector_default({
      source: new Vector_default2({
        useSpatialIndex: false,
        wrapX: !!options.wrapX
      }),
      style: options.style ? options.style : getDefaultStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });
    _this.SEGMENT_WRITERS_ = {
      "Point": _this.writePointGeometry_.bind(_this),
      "LineString": _this.writeLineStringGeometry_.bind(_this),
      "LinearRing": _this.writeLineStringGeometry_.bind(_this),
      "Polygon": _this.writePolygonGeometry_.bind(_this),
      "MultiPoint": _this.writeMultiPointGeometry_.bind(_this),
      "MultiLineString": _this.writeMultiLineStringGeometry_.bind(_this),
      "MultiPolygon": _this.writeMultiPolygonGeometry_.bind(_this),
      "Circle": _this.writeCircleGeometry_.bind(_this),
      "GeometryCollection": _this.writeGeometryCollectionGeometry_.bind(_this)
    };
    _this.source_ = null;
    _this.hitDetection_ = null;
    var features;
    if (options.features) {
      features = options.features;
    } else if (options.source) {
      _this.source_ = options.source;
      features = new Collection_default(_this.source_.getFeatures());
      _this.source_.addEventListener(VectorEventType_default.ADDFEATURE, _this.handleSourceAdd_.bind(_this));
      _this.source_.addEventListener(VectorEventType_default.REMOVEFEATURE, _this.handleSourceRemove_.bind(_this));
    }
    if (!features) {
      throw new Error("The modify interaction requires features, a source or a layer");
    }
    if (options.hitDetection) {
      _this.hitDetection_ = options.hitDetection;
    }
    _this.features_ = features;
    _this.features_.forEach(_this.addFeature_.bind(_this));
    _this.features_.addEventListener(CollectionEventType_default.ADD, _this.handleFeatureAdd_.bind(_this));
    _this.features_.addEventListener(CollectionEventType_default.REMOVE, _this.handleFeatureRemove_.bind(_this));
    _this.lastPointerEvent_ = null;
    _this.delta_ = [0, 0];
    _this.snapToPointer_ = options.snapToPointer === void 0 ? !_this.hitDetection_ : options.snapToPointer;
    return _this;
  }
  Modify2.prototype.addFeature_ = function(feature) {
    var geometry = feature.getGeometry();
    if (geometry) {
      var writer = this.SEGMENT_WRITERS_[geometry.getType()];
      if (writer) {
        writer(feature, geometry);
      }
    }
    var map = this.getMap();
    if (map && map.isRendered() && this.getActive()) {
      this.handlePointerAtPixel_(this.lastPixel_, map);
    }
    feature.addEventListener(EventType_default.CHANGE, this.boundHandleFeatureChange_);
  };
  Modify2.prototype.willModifyFeatures_ = function(evt, segments) {
    if (!this.featuresBeingModified_) {
      this.featuresBeingModified_ = new Collection_default();
      var features = this.featuresBeingModified_.getArray();
      for (var i = 0, ii = segments.length; i < ii; ++i) {
        var segment = segments[i];
        for (var s = 0, ss = segment.length; s < ss; ++s) {
          var feature = segment[s].feature;
          if (feature && features.indexOf(feature) === -1) {
            this.featuresBeingModified_.push(feature);
          }
        }
      }
      if (this.featuresBeingModified_.getLength() === 0) {
        this.featuresBeingModified_ = null;
      } else {
        this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYSTART, this.featuresBeingModified_, evt));
      }
    }
  };
  Modify2.prototype.removeFeature_ = function(feature) {
    this.removeFeatureSegmentData_(feature);
    if (this.vertexFeature_ && this.features_.getLength() === 0) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
    feature.removeEventListener(EventType_default.CHANGE, this.boundHandleFeatureChange_);
  };
  Modify2.prototype.removeFeatureSegmentData_ = function(feature) {
    var rBush = this.rBush_;
    var nodesToRemove = [];
    rBush.forEach(
      function(node) {
        if (feature === node.feature) {
          nodesToRemove.push(node);
        }
      }
    );
    for (var i = nodesToRemove.length - 1; i >= 0; --i) {
      var nodeToRemove = nodesToRemove[i];
      for (var j = this.dragSegments_.length - 1; j >= 0; --j) {
        if (this.dragSegments_[j][0] === nodeToRemove) {
          this.dragSegments_.splice(j, 1);
        }
      }
      rBush.remove(nodeToRemove);
    }
  };
  Modify2.prototype.setActive = function(active) {
    if (this.vertexFeature_ && !active) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
    _super.prototype.setActive.call(this, active);
  };
  Modify2.prototype.setMap = function(map) {
    this.overlay_.setMap(map);
    _super.prototype.setMap.call(this, map);
  };
  Modify2.prototype.getOverlay = function() {
    return this.overlay_;
  };
  Modify2.prototype.handleSourceAdd_ = function(event) {
    if (event.feature) {
      this.features_.push(event.feature);
    }
  };
  Modify2.prototype.handleSourceRemove_ = function(event) {
    if (event.feature) {
      this.features_.remove(event.feature);
    }
  };
  Modify2.prototype.handleFeatureAdd_ = function(evt) {
    this.addFeature_(evt.element);
  };
  Modify2.prototype.handleFeatureChange_ = function(evt) {
    if (!this.changingFeature_) {
      var feature = evt.target;
      this.removeFeature_(feature);
      this.addFeature_(feature);
    }
  };
  Modify2.prototype.handleFeatureRemove_ = function(evt) {
    var feature = evt.element;
    this.removeFeature_(feature);
  };
  Modify2.prototype.writePointGeometry_ = function(feature, geometry) {
    var coordinates = geometry.getCoordinates();
    var segmentData = {
      feature,
      geometry,
      segment: [coordinates, coordinates]
    };
    this.rBush_.insert(geometry.getExtent(), segmentData);
  };
  Modify2.prototype.writeMultiPointGeometry_ = function(feature, geometry) {
    var points = geometry.getCoordinates();
    for (var i = 0, ii = points.length; i < ii; ++i) {
      var coordinates = points[i];
      var segmentData = {
        feature,
        geometry,
        depth: [i],
        index: i,
        segment: [coordinates, coordinates]
      };
      this.rBush_.insert(geometry.getExtent(), segmentData);
    }
  };
  Modify2.prototype.writeLineStringGeometry_ = function(feature, geometry) {
    var coordinates = geometry.getCoordinates();
    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      var segmentData = {
        feature,
        geometry,
        index: i,
        segment
      };
      this.rBush_.insert(boundingExtent(segment), segmentData);
    }
  };
  Modify2.prototype.writeMultiLineStringGeometry_ = function(feature, geometry) {
    var lines = geometry.getCoordinates();
    for (var j = 0, jj = lines.length; j < jj; ++j) {
      var coordinates = lines[j];
      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = {
          feature,
          geometry,
          depth: [j],
          index: i,
          segment
        };
        this.rBush_.insert(boundingExtent(segment), segmentData);
      }
    }
  };
  Modify2.prototype.writePolygonGeometry_ = function(feature, geometry) {
    var rings = geometry.getCoordinates();
    for (var j = 0, jj = rings.length; j < jj; ++j) {
      var coordinates = rings[j];
      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = {
          feature,
          geometry,
          depth: [j],
          index: i,
          segment
        };
        this.rBush_.insert(boundingExtent(segment), segmentData);
      }
    }
  };
  Modify2.prototype.writeMultiPolygonGeometry_ = function(feature, geometry) {
    var polygons = geometry.getCoordinates();
    for (var k = 0, kk = polygons.length; k < kk; ++k) {
      var rings = polygons[k];
      for (var j = 0, jj = rings.length; j < jj; ++j) {
        var coordinates = rings[j];
        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          var segment = coordinates.slice(i, i + 2);
          var segmentData = {
            feature,
            geometry,
            depth: [j, k],
            index: i,
            segment
          };
          this.rBush_.insert(boundingExtent(segment), segmentData);
        }
      }
    }
  };
  Modify2.prototype.writeCircleGeometry_ = function(feature, geometry) {
    var coordinates = geometry.getCenter();
    var centerSegmentData = {
      feature,
      geometry,
      index: CIRCLE_CENTER_INDEX,
      segment: [coordinates, coordinates]
    };
    var circumferenceSegmentData = {
      feature,
      geometry,
      index: CIRCLE_CIRCUMFERENCE_INDEX,
      segment: [coordinates, coordinates]
    };
    var featureSegments = [centerSegmentData, circumferenceSegmentData];
    centerSegmentData.featureSegments = featureSegments;
    circumferenceSegmentData.featureSegments = featureSegments;
    this.rBush_.insert(createOrUpdateFromCoordinate(coordinates), centerSegmentData);
    var circleGeometry = geometry;
    var userProjection = getUserProjection();
    if (userProjection && this.getMap()) {
      var projection = this.getMap().getView().getProjection();
      circleGeometry = circleGeometry.clone().transform(userProjection, projection);
      circleGeometry = fromCircle(
        circleGeometry
      ).transform(projection, userProjection);
    }
    this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);
  };
  Modify2.prototype.writeGeometryCollectionGeometry_ = function(feature, geometry) {
    var geometries = geometry.getGeometriesArray();
    for (var i = 0; i < geometries.length; ++i) {
      var geometry_1 = geometries[i];
      var writer = this.SEGMENT_WRITERS_[geometry_1.getType()];
      writer(feature, geometry_1);
    }
  };
  Modify2.prototype.createOrUpdateVertexFeature_ = function(coordinates, features, geometries) {
    var vertexFeature = this.vertexFeature_;
    if (!vertexFeature) {
      vertexFeature = new Feature_default(new Point_default(coordinates));
      this.vertexFeature_ = vertexFeature;
      this.overlay_.getSource().addFeature(vertexFeature);
    } else {
      var geometry = vertexFeature.getGeometry();
      geometry.setCoordinates(coordinates);
    }
    vertexFeature.set("features", features);
    vertexFeature.set("geometries", geometries);
    return vertexFeature;
  };
  Modify2.prototype.handleEvent = function(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }
    this.lastPointerEvent_ = mapBrowserEvent;
    var handled;
    if (!mapBrowserEvent.map.getView().getInteracting() && mapBrowserEvent.type == MapBrowserEventType_default.POINTERMOVE && !this.handlingDownUpSequence) {
      this.handlePointerMove_(mapBrowserEvent);
    }
    if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
      if (mapBrowserEvent.type != MapBrowserEventType_default.SINGLECLICK || !this.ignoreNextSingleClick_) {
        handled = this.removePoint();
      } else {
        handled = true;
      }
    }
    if (mapBrowserEvent.type == MapBrowserEventType_default.SINGLECLICK) {
      this.ignoreNextSingleClick_ = false;
    }
    return _super.prototype.handleEvent.call(this, mapBrowserEvent) && !handled;
  };
  Modify2.prototype.handleDragEvent = function(evt) {
    this.ignoreNextSingleClick_ = false;
    this.willModifyFeatures_(evt, this.dragSegments_);
    var vertex = [
      evt.coordinate[0] + this.delta_[0],
      evt.coordinate[1] + this.delta_[1]
    ];
    var features = [];
    var geometries = [];
    for (var i = 0, ii = this.dragSegments_.length; i < ii; ++i) {
      var dragSegment = this.dragSegments_[i];
      var segmentData = dragSegment[0];
      var feature = segmentData.feature;
      if (features.indexOf(feature) === -1) {
        features.push(feature);
      }
      var geometry = segmentData.geometry;
      if (geometries.indexOf(geometry) === -1) {
        geometries.push(geometry);
      }
      var depth = segmentData.depth;
      var coordinates = void 0;
      var segment = segmentData.segment;
      var index = dragSegment[1];
      while (vertex.length < geometry.getStride()) {
        vertex.push(segment[index][vertex.length]);
      }
      switch (geometry.getType()) {
        case "Point":
          coordinates = vertex;
          segment[0] = vertex;
          segment[1] = vertex;
          break;
        case "MultiPoint":
          coordinates = geometry.getCoordinates();
          coordinates[segmentData.index] = vertex;
          segment[0] = vertex;
          segment[1] = vertex;
          break;
        case "LineString":
          coordinates = geometry.getCoordinates();
          coordinates[segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case "MultiLineString":
          coordinates = geometry.getCoordinates();
          coordinates[depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case "Polygon":
          coordinates = geometry.getCoordinates();
          coordinates[depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case "MultiPolygon":
          coordinates = geometry.getCoordinates();
          coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case "Circle":
          segment[0] = vertex;
          segment[1] = vertex;
          if (segmentData.index === CIRCLE_CENTER_INDEX) {
            this.changingFeature_ = true;
            geometry.setCenter(vertex);
            this.changingFeature_ = false;
          } else {
            this.changingFeature_ = true;
            var projection = evt.map.getView().getProjection();
            var radius = distance(fromUserCoordinate(geometry.getCenter(), projection), fromUserCoordinate(vertex, projection));
            var userProjection = getUserProjection();
            if (userProjection) {
              var circleGeometry = geometry.clone().transform(userProjection, projection);
              circleGeometry.setRadius(radius);
              radius = circleGeometry.transform(projection, userProjection).getRadius();
            }
            geometry.setRadius(radius);
            this.changingFeature_ = false;
          }
          break;
        default:
      }
      if (coordinates) {
        this.setGeometryCoordinates_(geometry, coordinates);
      }
    }
    this.createOrUpdateVertexFeature_(vertex, features, geometries);
  };
  Modify2.prototype.handleDownEvent = function(evt) {
    if (!this.condition_(evt)) {
      return false;
    }
    var pixelCoordinate = evt.coordinate;
    this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);
    this.dragSegments_.length = 0;
    this.featuresBeingModified_ = null;
    var vertexFeature = this.vertexFeature_;
    if (vertexFeature) {
      var projection = evt.map.getView().getProjection();
      var insertVertices = [];
      var vertex = vertexFeature.getGeometry().getCoordinates();
      var vertexExtent = boundingExtent([vertex]);
      var segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
      var componentSegments = {};
      segmentDataMatches.sort(compareIndexes);
      for (var i = 0, ii = segmentDataMatches.length; i < ii; ++i) {
        var segmentDataMatch = segmentDataMatches[i];
        var segment = segmentDataMatch.segment;
        var uid = getUid(segmentDataMatch.geometry);
        var depth = segmentDataMatch.depth;
        if (depth) {
          uid += "-" + depth.join("-");
        }
        if (!componentSegments[uid]) {
          componentSegments[uid] = new Array(2);
        }
        if (segmentDataMatch.geometry.getType() === "Circle" && segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {
          var closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch, projection);
          if (equals3(closestVertex, vertex) && !componentSegments[uid][0]) {
            this.dragSegments_.push([segmentDataMatch, 0]);
            componentSegments[uid][0] = segmentDataMatch;
          }
          continue;
        }
        if (equals3(segment[0], vertex) && !componentSegments[uid][0]) {
          this.dragSegments_.push([segmentDataMatch, 0]);
          componentSegments[uid][0] = segmentDataMatch;
          continue;
        }
        if (equals3(segment[1], vertex) && !componentSegments[uid][1]) {
          if (componentSegments[uid][0] && componentSegments[uid][0].index === 0) {
            var coordinates = segmentDataMatch.geometry.getCoordinates();
            switch (segmentDataMatch.geometry.getType()) {
              case "LineString":
              case "MultiLineString":
                continue;
              case "MultiPolygon":
                coordinates = coordinates[depth[1]];
              case "Polygon":
                if (segmentDataMatch.index !== coordinates[depth[0]].length - 2) {
                  continue;
                }
                break;
              default:
            }
          }
          this.dragSegments_.push([segmentDataMatch, 1]);
          componentSegments[uid][1] = segmentDataMatch;
          continue;
        }
        if (getUid(segment) in this.vertexSegments_ && !componentSegments[uid][0] && !componentSegments[uid][1] && this.insertVertexCondition_(evt)) {
          insertVertices.push(segmentDataMatch);
        }
      }
      if (insertVertices.length) {
        this.willModifyFeatures_(evt, [insertVertices]);
      }
      for (var j = insertVertices.length - 1; j >= 0; --j) {
        this.insertVertex_(insertVertices[j], vertex);
      }
    }
    return !!this.vertexFeature_;
  };
  Modify2.prototype.handleUpEvent = function(evt) {
    for (var i = this.dragSegments_.length - 1; i >= 0; --i) {
      var segmentData = this.dragSegments_[i][0];
      var geometry = segmentData.geometry;
      if (geometry.getType() === "Circle") {
        var coordinates = geometry.getCenter();
        var centerSegmentData = segmentData.featureSegments[0];
        var circumferenceSegmentData = segmentData.featureSegments[1];
        centerSegmentData.segment[0] = coordinates;
        centerSegmentData.segment[1] = coordinates;
        circumferenceSegmentData.segment[0] = coordinates;
        circumferenceSegmentData.segment[1] = coordinates;
        this.rBush_.update(createOrUpdateFromCoordinate(coordinates), centerSegmentData);
        var circleGeometry = geometry;
        var userProjection = getUserProjection();
        if (userProjection) {
          var projection = evt.map.getView().getProjection();
          circleGeometry = circleGeometry.clone().transform(userProjection, projection);
          circleGeometry = fromCircle(circleGeometry).transform(projection, userProjection);
        }
        this.rBush_.update(circleGeometry.getExtent(), circumferenceSegmentData);
      } else {
        this.rBush_.update(boundingExtent(segmentData.segment), segmentData);
      }
    }
    if (this.featuresBeingModified_) {
      this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
      this.featuresBeingModified_ = null;
    }
    return false;
  };
  Modify2.prototype.handlePointerMove_ = function(evt) {
    this.lastPixel_ = evt.pixel;
    this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);
  };
  Modify2.prototype.handlePointerAtPixel_ = function(pixel, map, opt_coordinate) {
    var _this = this;
    var pixelCoordinate = opt_coordinate || map.getCoordinateFromPixel(pixel);
    var projection = map.getView().getProjection();
    var sortByDistance = function(a, b) {
      return projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) - projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection);
    };
    var nodes;
    var hitPointGeometry;
    if (this.hitDetection_) {
      var layerFilter = typeof this.hitDetection_ === "object" ? function(layer) {
        return layer === _this.hitDetection_;
      } : void 0;
      map.forEachFeatureAtPixel(pixel, function(feature, layer, geometry) {
        geometry = geometry || feature.getGeometry();
        if (geometry.getType() === "Point" && includes(_this.features_.getArray(), feature)) {
          hitPointGeometry = geometry;
          var coordinate = geometry.getFlatCoordinates().slice(0, 2);
          nodes = [
            {
              feature,
              geometry,
              segment: [coordinate, coordinate]
            }
          ];
        }
        return true;
      }, { layerFilter });
    }
    if (!nodes) {
      var viewExtent = fromUserExtent(createOrUpdateFromCoordinate(pixelCoordinate, tempExtent), projection);
      var buffer2 = map.getView().getResolution() * this.pixelTolerance_;
      var box = toUserExtent(buffer(viewExtent, buffer2, tempExtent), projection);
      nodes = this.rBush_.getInExtent(box);
    }
    if (nodes && nodes.length > 0) {
      var node = nodes.sort(sortByDistance)[0];
      var closestSegment = node.segment;
      var vertex = closestOnSegmentData(pixelCoordinate, node, projection);
      var vertexPixel = map.getPixelFromCoordinate(vertex);
      var dist = distance(pixel, vertexPixel);
      if (hitPointGeometry || dist <= this.pixelTolerance_) {
        var vertexSegments = {};
        vertexSegments[getUid(closestSegment)] = true;
        if (!this.snapToPointer_) {
          this.delta_[0] = vertex[0] - pixelCoordinate[0];
          this.delta_[1] = vertex[1] - pixelCoordinate[1];
        }
        if (node.geometry.getType() === "Circle" && node.index === CIRCLE_CIRCUMFERENCE_INDEX) {
          this.snappedToVertex_ = true;
          this.createOrUpdateVertexFeature_(vertex, [node.feature], [node.geometry]);
        } else {
          var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
          var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
          var squaredDist1 = squaredDistance(vertexPixel, pixel1);
          var squaredDist2 = squaredDistance(vertexPixel, pixel2);
          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
          this.snappedToVertex_ = dist <= this.pixelTolerance_;
          if (this.snappedToVertex_) {
            vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
          }
          this.createOrUpdateVertexFeature_(vertex, [node.feature], [node.geometry]);
          var geometries = {};
          geometries[getUid(node.geometry)] = true;
          for (var i = 1, ii = nodes.length; i < ii; ++i) {
            var segment = nodes[i].segment;
            if (equals3(closestSegment[0], segment[0]) && equals3(closestSegment[1], segment[1]) || equals3(closestSegment[0], segment[1]) && equals3(closestSegment[1], segment[0])) {
              var geometryUid = getUid(nodes[i].geometry);
              if (!(geometryUid in geometries)) {
                geometries[geometryUid] = true;
                vertexSegments[getUid(segment)] = true;
              }
            } else {
              break;
            }
          }
        }
        this.vertexSegments_ = vertexSegments;
        return;
      }
    }
    if (this.vertexFeature_) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
  };
  Modify2.prototype.insertVertex_ = function(segmentData, vertex) {
    var segment = segmentData.segment;
    var feature = segmentData.feature;
    var geometry = segmentData.geometry;
    var depth = segmentData.depth;
    var index = segmentData.index;
    var coordinates;
    while (vertex.length < geometry.getStride()) {
      vertex.push(0);
    }
    switch (geometry.getType()) {
      case "MultiLineString":
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]].splice(index + 1, 0, vertex);
        break;
      case "Polygon":
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]].splice(index + 1, 0, vertex);
        break;
      case "MultiPolygon":
        coordinates = geometry.getCoordinates();
        coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
        break;
      case "LineString":
        coordinates = geometry.getCoordinates();
        coordinates.splice(index + 1, 0, vertex);
        break;
      default:
        return;
    }
    this.setGeometryCoordinates_(geometry, coordinates);
    var rTree = this.rBush_;
    rTree.remove(segmentData);
    this.updateSegmentIndices_(geometry, index, depth, 1);
    var newSegmentData = {
      segment: [segment[0], vertex],
      feature,
      geometry,
      depth,
      index
    };
    rTree.insert(boundingExtent(newSegmentData.segment), newSegmentData);
    this.dragSegments_.push([newSegmentData, 1]);
    var newSegmentData2 = {
      segment: [vertex, segment[1]],
      feature,
      geometry,
      depth,
      index: index + 1
    };
    rTree.insert(boundingExtent(newSegmentData2.segment), newSegmentData2);
    this.dragSegments_.push([newSegmentData2, 0]);
    this.ignoreNextSingleClick_ = true;
  };
  Modify2.prototype.removePoint = function() {
    if (this.lastPointerEvent_ && this.lastPointerEvent_.type != MapBrowserEventType_default.POINTERDRAG) {
      var evt = this.lastPointerEvent_;
      this.willModifyFeatures_(evt, this.dragSegments_);
      var removed = this.removeVertex_();
      if (this.featuresBeingModified_) {
        this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
      }
      this.featuresBeingModified_ = null;
      return removed;
    }
    return false;
  };
  Modify2.prototype.removeVertex_ = function() {
    var dragSegments = this.dragSegments_;
    var segmentsByFeature = {};
    var deleted = false;
    var component, coordinates, dragSegment, geometry, i, index, left;
    var newIndex, right, segmentData, uid;
    for (i = dragSegments.length - 1; i >= 0; --i) {
      dragSegment = dragSegments[i];
      segmentData = dragSegment[0];
      uid = getUid(segmentData.feature);
      if (segmentData.depth) {
        uid += "-" + segmentData.depth.join("-");
      }
      if (!(uid in segmentsByFeature)) {
        segmentsByFeature[uid] = {};
      }
      if (dragSegment[1] === 0) {
        segmentsByFeature[uid].right = segmentData;
        segmentsByFeature[uid].index = segmentData.index;
      } else if (dragSegment[1] == 1) {
        segmentsByFeature[uid].left = segmentData;
        segmentsByFeature[uid].index = segmentData.index + 1;
      }
    }
    for (uid in segmentsByFeature) {
      right = segmentsByFeature[uid].right;
      left = segmentsByFeature[uid].left;
      index = segmentsByFeature[uid].index;
      newIndex = index - 1;
      if (left !== void 0) {
        segmentData = left;
      } else {
        segmentData = right;
      }
      if (newIndex < 0) {
        newIndex = 0;
      }
      geometry = segmentData.geometry;
      coordinates = geometry.getCoordinates();
      component = coordinates;
      deleted = false;
      switch (geometry.getType()) {
        case "MultiLineString":
          if (coordinates[segmentData.depth[0]].length > 2) {
            coordinates[segmentData.depth[0]].splice(index, 1);
            deleted = true;
          }
          break;
        case "LineString":
          if (coordinates.length > 2) {
            coordinates.splice(index, 1);
            deleted = true;
          }
          break;
        case "MultiPolygon":
          component = component[segmentData.depth[1]];
        case "Polygon":
          component = component[segmentData.depth[0]];
          if (component.length > 4) {
            if (index == component.length - 1) {
              index = 0;
            }
            component.splice(index, 1);
            deleted = true;
            if (index === 0) {
              component.pop();
              component.push(component[0]);
              newIndex = component.length - 1;
            }
          }
          break;
        default:
      }
      if (deleted) {
        this.setGeometryCoordinates_(geometry, coordinates);
        var segments = [];
        if (left !== void 0) {
          this.rBush_.remove(left);
          segments.push(left.segment[0]);
        }
        if (right !== void 0) {
          this.rBush_.remove(right);
          segments.push(right.segment[1]);
        }
        if (left !== void 0 && right !== void 0) {
          var newSegmentData = {
            depth: segmentData.depth,
            feature: segmentData.feature,
            geometry: segmentData.geometry,
            index: newIndex,
            segment: segments
          };
          this.rBush_.insert(boundingExtent(newSegmentData.segment), newSegmentData);
        }
        this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);
        if (this.vertexFeature_) {
          this.overlay_.getSource().removeFeature(this.vertexFeature_);
          this.vertexFeature_ = null;
        }
        dragSegments.length = 0;
      }
    }
    return deleted;
  };
  Modify2.prototype.setGeometryCoordinates_ = function(geometry, coordinates) {
    this.changingFeature_ = true;
    geometry.setCoordinates(coordinates);
    this.changingFeature_ = false;
  };
  Modify2.prototype.updateSegmentIndices_ = function(geometry, index, depth, delta) {
    this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {
      if (segmentDataMatch.geometry === geometry && (depth === void 0 || segmentDataMatch.depth === void 0 || equals(segmentDataMatch.depth, depth)) && segmentDataMatch.index > index) {
        segmentDataMatch.index += delta;
      }
    });
  };
  return Modify2;
}(Pointer_default);
function compareIndexes(a, b) {
  return a.index - b.index;
}
function projectedDistanceToSegmentDataSquared(pointCoordinates, segmentData, projection) {
  var geometry = segmentData.geometry;
  if (geometry.getType() === "Circle") {
    var circleGeometry = geometry;
    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
      var userProjection = getUserProjection();
      if (userProjection) {
        circleGeometry = circleGeometry.clone().transform(userProjection, projection);
      }
      var distanceToCenterSquared = squaredDistance(circleGeometry.getCenter(), fromUserCoordinate(pointCoordinates, projection));
      var distanceToCircumference = Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
      return distanceToCircumference * distanceToCircumference;
    }
  }
  var coordinate = fromUserCoordinate(pointCoordinates, projection);
  tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);
  tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);
  return squaredDistanceToSegment(coordinate, tempSegment);
}
function closestOnSegmentData(pointCoordinates, segmentData, projection) {
  var geometry = segmentData.geometry;
  if (geometry.getType() === "Circle" && segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
    var circleGeometry = geometry;
    var userProjection = getUserProjection();
    if (userProjection) {
      circleGeometry = circleGeometry.clone().transform(userProjection, projection);
    }
    return toUserCoordinate(circleGeometry.getClosestPoint(fromUserCoordinate(pointCoordinates, projection)), projection);
  }
  var coordinate = fromUserCoordinate(pointCoordinates, projection);
  tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);
  tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);
  return toUserCoordinate(closestOnSegment(coordinate, tempSegment), projection);
}
function getDefaultStyleFunction() {
  var style = createEditingStyle();
  return function(feature, resolution) {
    return style["Point"];
  };
}

// node_modules/ol/interaction/Select.js
var __extends35 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SelectEventType = {
  SELECT: "select"
};
var SelectEvent = function(_super) {
  __extends35(SelectEvent2, _super);
  function SelectEvent2(type, selected, deselected, mapBrowserEvent) {
    var _this = _super.call(this, type) || this;
    _this.selected = selected;
    _this.deselected = deselected;
    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }
  return SelectEvent2;
}(Event_default);
var originalFeatureStyles = {};
var Select = function(_super) {
  __extends35(Select2, _super);
  function Select2(opt_options) {
    var _this = _super.call(this) || this;
    _this.on;
    _this.once;
    _this.un;
    var options = opt_options ? opt_options : {};
    _this.boundAddFeature_ = _this.addFeature_.bind(_this);
    _this.boundRemoveFeature_ = _this.removeFeature_.bind(_this);
    _this.condition_ = options.condition ? options.condition : singleClick;
    _this.addCondition_ = options.addCondition ? options.addCondition : never;
    _this.removeCondition_ = options.removeCondition ? options.removeCondition : never;
    _this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : shiftKeyOnly;
    _this.multi_ = options.multi ? options.multi : false;
    _this.filter_ = options.filter ? options.filter : TRUE;
    _this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
    _this.style_ = options.style !== void 0 ? options.style : getDefaultStyleFunction2();
    _this.features_ = options.features || new Collection_default();
    var layerFilter;
    if (options.layers) {
      if (typeof options.layers === "function") {
        layerFilter = options.layers;
      } else {
        var layers_1 = options.layers;
        layerFilter = function(layer) {
          return includes(layers_1, layer);
        };
      }
    } else {
      layerFilter = TRUE;
    }
    _this.layerFilter_ = layerFilter;
    _this.featureLayerAssociation_ = {};
    return _this;
  }
  Select2.prototype.addFeatureLayerAssociation_ = function(feature, layer) {
    this.featureLayerAssociation_[getUid(feature)] = layer;
  };
  Select2.prototype.getFeatures = function() {
    return this.features_;
  };
  Select2.prototype.getHitTolerance = function() {
    return this.hitTolerance_;
  };
  Select2.prototype.getLayer = function(feature) {
    return this.featureLayerAssociation_[getUid(feature)];
  };
  Select2.prototype.setHitTolerance = function(hitTolerance) {
    this.hitTolerance_ = hitTolerance;
  };
  Select2.prototype.setMap = function(map) {
    var currentMap = this.getMap();
    if (currentMap && this.style_) {
      this.features_.forEach(this.restorePreviousStyle_.bind(this));
    }
    _super.prototype.setMap.call(this, map);
    if (map) {
      this.features_.addEventListener(CollectionEventType_default.ADD, this.boundAddFeature_);
      this.features_.addEventListener(CollectionEventType_default.REMOVE, this.boundRemoveFeature_);
      if (this.style_) {
        this.features_.forEach(this.applySelectedStyle_.bind(this));
      }
    } else {
      this.features_.removeEventListener(CollectionEventType_default.ADD, this.boundAddFeature_);
      this.features_.removeEventListener(CollectionEventType_default.REMOVE, this.boundRemoveFeature_);
    }
  };
  Select2.prototype.addFeature_ = function(evt) {
    var feature = evt.element;
    if (this.style_) {
      this.applySelectedStyle_(feature);
    }
    if (!this.getLayer(feature)) {
      var layer = this.getMap().getAllLayers().find(function(layer2) {
        if (layer2 instanceof Vector_default && layer2.getSource() && layer2.getSource().hasFeature(feature)) {
          return layer2;
        }
      });
      if (layer) {
        this.addFeatureLayerAssociation_(feature, layer);
      }
    }
  };
  Select2.prototype.removeFeature_ = function(evt) {
    var feature = evt.element;
    if (this.style_) {
      this.restorePreviousStyle_(feature);
    }
  };
  Select2.prototype.getStyle = function() {
    return this.style_;
  };
  Select2.prototype.applySelectedStyle_ = function(feature) {
    var key = getUid(feature);
    if (!(key in originalFeatureStyles)) {
      originalFeatureStyles[key] = feature.getStyle();
    }
    feature.setStyle(this.style_);
  };
  Select2.prototype.restorePreviousStyle_ = function(feature) {
    var interactions = this.getMap().getInteractions().getArray();
    for (var i = interactions.length - 1; i >= 0; --i) {
      var interaction = interactions[i];
      if (interaction !== this && interaction instanceof Select2 && interaction.getStyle() && interaction.getFeatures().getArray().lastIndexOf(feature) !== -1) {
        feature.setStyle(interaction.getStyle());
        return;
      }
    }
    var key = getUid(feature);
    feature.setStyle(originalFeatureStyles[key]);
    delete originalFeatureStyles[key];
  };
  Select2.prototype.removeFeatureLayerAssociation_ = function(feature) {
    delete this.featureLayerAssociation_[getUid(feature)];
  };
  Select2.prototype.handleEvent = function(mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }
    var add2 = this.addCondition_(mapBrowserEvent);
    var remove = this.removeCondition_(mapBrowserEvent);
    var toggle = this.toggleCondition_(mapBrowserEvent);
    var set = !add2 && !remove && !toggle;
    var map = mapBrowserEvent.map;
    var features = this.getFeatures();
    var deselected = [];
    var selected = [];
    if (set) {
      clear(this.featureLayerAssociation_);
      map.forEachFeatureAtPixel(
        mapBrowserEvent.pixel,
        function(feature2, layer) {
          if (this.filter_(feature2, layer)) {
            this.addFeatureLayerAssociation_(feature2, layer);
            selected.push(feature2);
            return !this.multi_;
          }
        }.bind(this),
        {
          layerFilter: this.layerFilter_,
          hitTolerance: this.hitTolerance_
        }
      );
      for (var i = features.getLength() - 1; i >= 0; --i) {
        var feature = features.item(i);
        var index = selected.indexOf(feature);
        if (index > -1) {
          selected.splice(index, 1);
        } else {
          features.remove(feature);
          deselected.push(feature);
        }
      }
      if (selected.length !== 0) {
        features.extend(selected);
      }
    } else {
      map.forEachFeatureAtPixel(
        mapBrowserEvent.pixel,
        function(feature2, layer) {
          if (this.filter_(feature2, layer)) {
            if ((add2 || toggle) && !includes(features.getArray(), feature2)) {
              this.addFeatureLayerAssociation_(feature2, layer);
              selected.push(feature2);
            } else if ((remove || toggle) && includes(features.getArray(), feature2)) {
              deselected.push(feature2);
              this.removeFeatureLayerAssociation_(feature2);
            }
            return !this.multi_;
          }
        }.bind(this),
        {
          layerFilter: this.layerFilter_,
          hitTolerance: this.hitTolerance_
        }
      );
      for (var j = deselected.length - 1; j >= 0; --j) {
        features.remove(deselected[j]);
      }
      features.extend(selected);
    }
    if (selected.length > 0 || deselected.length > 0) {
      this.dispatchEvent(new SelectEvent(SelectEventType.SELECT, selected, deselected, mapBrowserEvent));
    }
    return true;
  };
  return Select2;
}(Interaction_default);
function getDefaultStyleFunction2() {
  var styles = createEditingStyle();
  extend(styles["Polygon"], styles["LineString"]);
  extend(styles["GeometryCollection"], styles["LineString"]);
  return function(feature) {
    if (!feature.getGeometry()) {
      return null;
    }
    return styles[feature.getGeometry().getType()];
  };
}

// node_modules/ol/interaction/Translate.js
var __extends36 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TranslateEventType = {
  TRANSLATESTART: "translatestart",
  TRANSLATING: "translating",
  TRANSLATEEND: "translateend"
};
var TranslateEvent = function(_super) {
  __extends36(TranslateEvent2, _super);
  function TranslateEvent2(type, features, coordinate, startCoordinate, mapBrowserEvent) {
    var _this = _super.call(this, type) || this;
    _this.features = features;
    _this.coordinate = coordinate;
    _this.startCoordinate = startCoordinate;
    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }
  return TranslateEvent2;
}(Event_default);
var Translate = function(_super) {
  __extends36(Translate2, _super);
  function Translate2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, options) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.lastCoordinate_ = null;
    _this.startCoordinate_ = null;
    _this.features_ = options.features !== void 0 ? options.features : null;
    var layerFilter;
    if (options.layers && !_this.features_) {
      if (typeof options.layers === "function") {
        layerFilter = options.layers;
      } else {
        var layers_1 = options.layers;
        layerFilter = function(layer) {
          return includes(layers_1, layer);
        };
      }
    } else {
      layerFilter = TRUE;
    }
    _this.layerFilter_ = layerFilter;
    _this.filter_ = options.filter && !_this.features_ ? options.filter : TRUE;
    _this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
    _this.condition_ = options.condition ? options.condition : always;
    _this.lastFeature_ = null;
    _this.addChangeListener(Property_default.ACTIVE, _this.handleActiveChanged_);
    return _this;
  }
  Translate2.prototype.handleDownEvent = function(event) {
    if (!event.originalEvent || !this.condition_(event)) {
      return false;
    }
    this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);
    if (!this.lastCoordinate_ && this.lastFeature_) {
      this.startCoordinate_ = event.coordinate;
      this.lastCoordinate_ = event.coordinate;
      this.handleMoveEvent(event);
      var features = this.features_ || new Collection_default([this.lastFeature_]);
      this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATESTART, features, event.coordinate, this.startCoordinate_, event));
      return true;
    }
    return false;
  };
  Translate2.prototype.handleUpEvent = function(event) {
    if (this.lastCoordinate_) {
      this.lastCoordinate_ = null;
      this.handleMoveEvent(event);
      var features = this.features_ || new Collection_default([this.lastFeature_]);
      this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATEEND, features, event.coordinate, this.startCoordinate_, event));
      this.startCoordinate_ = null;
      return true;
    }
    return false;
  };
  Translate2.prototype.handleDragEvent = function(event) {
    if (this.lastCoordinate_) {
      var newCoordinate = event.coordinate;
      var deltaX_1 = newCoordinate[0] - this.lastCoordinate_[0];
      var deltaY_1 = newCoordinate[1] - this.lastCoordinate_[1];
      var features = this.features_ || new Collection_default([this.lastFeature_]);
      features.forEach(function(feature) {
        var geom = feature.getGeometry();
        geom.translate(deltaX_1, deltaY_1);
        feature.setGeometry(geom);
      });
      this.lastCoordinate_ = newCoordinate;
      this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATING, features, newCoordinate, this.startCoordinate_, event));
    }
  };
  Translate2.prototype.handleMoveEvent = function(event) {
    var elem = event.map.getViewport();
    if (this.featuresAtPixel_(event.pixel, event.map)) {
      elem.classList.remove(this.lastCoordinate_ ? "ol-grab" : "ol-grabbing");
      elem.classList.add(this.lastCoordinate_ ? "ol-grabbing" : "ol-grab");
    } else {
      elem.classList.remove("ol-grab", "ol-grabbing");
    }
  };
  Translate2.prototype.featuresAtPixel_ = function(pixel, map) {
    return map.forEachFeatureAtPixel(pixel, function(feature, layer) {
      if (this.filter_(feature, layer)) {
        if (!this.features_ || includes(this.features_.getArray(), feature)) {
          return feature;
        }
      }
    }.bind(this), {
      layerFilter: this.layerFilter_,
      hitTolerance: this.hitTolerance_
    });
  };
  Translate2.prototype.getHitTolerance = function() {
    return this.hitTolerance_;
  };
  Translate2.prototype.setHitTolerance = function(hitTolerance) {
    this.hitTolerance_ = hitTolerance;
  };
  Translate2.prototype.setMap = function(map) {
    var oldMap = this.getMap();
    _super.prototype.setMap.call(this, map);
    this.updateState_(oldMap);
  };
  Translate2.prototype.handleActiveChanged_ = function() {
    this.updateState_(null);
  };
  Translate2.prototype.updateState_ = function(oldMap) {
    var map = this.getMap();
    var active = this.getActive();
    if (!map || !active) {
      map = map || oldMap;
      if (map) {
        var elem = map.getViewport();
        elem.classList.remove("ol-grab", "ol-grabbing");
      }
    }
  };
  return Translate2;
}(Pointer_default);

// node_modules/ol/interaction.js
function defaults2(opt_options) {
  var options = opt_options ? opt_options : {};
  var interactions = new Collection_default();
  var kinetic = new Kinetic_default(-5e-3, 0.05, 100);
  var altShiftDragRotate = options.altShiftDragRotate !== void 0 ? options.altShiftDragRotate : true;
  if (altShiftDragRotate) {
    interactions.push(new DragRotate_default());
  }
  var doubleClickZoom = options.doubleClickZoom !== void 0 ? options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(new DoubleClickZoom_default({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }
  var dragPan = options.dragPan !== void 0 ? options.dragPan : true;
  if (dragPan) {
    interactions.push(new DragPan_default({
      onFocusOnly: options.onFocusOnly,
      kinetic
    }));
  }
  var pinchRotate = options.pinchRotate !== void 0 ? options.pinchRotate : true;
  if (pinchRotate) {
    interactions.push(new PinchRotate_default());
  }
  var pinchZoom = options.pinchZoom !== void 0 ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(new PinchZoom_default({
      duration: options.zoomDuration
    }));
  }
  var keyboard = options.keyboard !== void 0 ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new KeyboardPan_default());
    interactions.push(new KeyboardZoom_default({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }
  var mouseWheelZoom = options.mouseWheelZoom !== void 0 ? options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(new MouseWheelZoom_default({
      onFocusOnly: options.onFocusOnly,
      duration: options.zoomDuration
    }));
  }
  var shiftDragZoom = options.shiftDragZoom !== void 0 ? options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(new DragZoom_default({
      duration: options.zoomDuration
    }));
  }
  return interactions;
}

// node_modules/ol/Map.js
var __extends37 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Map = function(_super) {
  __extends37(Map2, _super);
  function Map2(options) {
    options = assign({}, options);
    if (!options.controls) {
      options.controls = defaults();
    }
    if (!options.interactions) {
      options.interactions = defaults2({
        onFocusOnly: true
      });
    }
    return _super.call(this, options) || this;
  }
  Map2.prototype.createRenderer = function() {
    return new Composite_default(this);
  };
  return Map2;
}(PluggableMap_default);
var Map_default2 = Map;

// node_modules/ol/VectorRenderTile.js
var __extends38 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var canvasPool = [];
var VectorRenderTile = function(_super) {
  __extends38(VectorRenderTile2, _super);
  function VectorRenderTile2(tileCoord, state, urlTileCoord, getSourceTiles) {
    var _this = _super.call(this, tileCoord, state, { transition: 0 }) || this;
    _this.context_ = {};
    _this.executorGroups = {};
    _this.declutterExecutorGroups = {};
    _this.loadingSourceTiles = 0;
    _this.hitDetectionImageData = {};
    _this.replayState_ = {};
    _this.sourceTiles = [];
    _this.errorTileKeys = {};
    _this.wantedResolution;
    _this.getSourceTiles = getSourceTiles.bind(void 0, _this);
    _this.wrappedTileCoord = urlTileCoord;
    return _this;
  }
  VectorRenderTile2.prototype.getContext = function(layer) {
    var key = getUid(layer);
    if (!(key in this.context_)) {
      this.context_[key] = createCanvasContext2D(1, 1, canvasPool);
    }
    return this.context_[key];
  };
  VectorRenderTile2.prototype.hasContext = function(layer) {
    return getUid(layer) in this.context_;
  };
  VectorRenderTile2.prototype.getImage = function(layer) {
    return this.hasContext(layer) ? this.getContext(layer).canvas : null;
  };
  VectorRenderTile2.prototype.getReplayState = function(layer) {
    var key = getUid(layer);
    if (!(key in this.replayState_)) {
      this.replayState_[key] = {
        dirty: false,
        renderedRenderOrder: null,
        renderedResolution: NaN,
        renderedRevision: -1,
        renderedTileResolution: NaN,
        renderedTileRevision: -1,
        renderedTileZ: -1
      };
    }
    return this.replayState_[key];
  };
  VectorRenderTile2.prototype.load = function() {
    this.getSourceTiles();
  };
  VectorRenderTile2.prototype.release = function() {
    for (var key in this.context_) {
      var context = this.context_[key];
      releaseCanvas(context);
      canvasPool.push(context.canvas);
      delete this.context_[key];
    }
    _super.prototype.release.call(this);
  };
  return VectorRenderTile2;
}(Tile_default);
var VectorRenderTile_default = VectorRenderTile;

// node_modules/ol/VectorTile.js
var __extends39 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var VectorTile = function(_super) {
  __extends39(VectorTile2, _super);
  function VectorTile2(tileCoord, state, src, format, tileLoadFunction, opt_options) {
    var _this = _super.call(this, tileCoord, state, opt_options) || this;
    _this.extent = null;
    _this.format_ = format;
    _this.features_ = null;
    _this.loader_;
    _this.projection = null;
    _this.resolution;
    _this.tileLoadFunction_ = tileLoadFunction;
    _this.url_ = src;
    _this.key = src;
    return _this;
  }
  VectorTile2.prototype.getFormat = function() {
    return this.format_;
  };
  VectorTile2.prototype.getFeatures = function() {
    return this.features_;
  };
  VectorTile2.prototype.load = function() {
    if (this.state == TileState_default.IDLE) {
      this.setState(TileState_default.LOADING);
      this.tileLoadFunction_(this, this.url_);
      if (this.loader_) {
        this.loader_(this.extent, this.resolution, this.projection);
      }
    }
  };
  VectorTile2.prototype.onLoad = function(features, dataProjection) {
    this.setFeatures(features);
  };
  VectorTile2.prototype.onError = function() {
    this.setState(TileState_default.ERROR);
  };
  VectorTile2.prototype.setFeatures = function(features) {
    this.features_ = features;
    this.setState(TileState_default.LOADED);
  };
  VectorTile2.prototype.setLoader = function(loader) {
    this.loader_ = loader;
  };
  return VectorTile2;
}(Tile_default);
var VectorTile_default = VectorTile;
export {
  AssertionError_default as AssertionError,
  Collection_default as Collection,
  Disposable_default as Disposable,
  Feature_default as Feature,
  Geolocation_default as Geolocation,
  Graticule_default as Graticule,
  Image_default as Image,
  ImageBase_default as ImageBase,
  ImageCanvas_default as ImageCanvas,
  ImageTile_default as ImageTile,
  Kinetic_default as Kinetic,
  Map_default2 as Map,
  MapBrowserEvent_default as MapBrowserEvent,
  MapBrowserEventHandler_default as MapBrowserEventHandler,
  MapEvent_default as MapEvent,
  Object_default as Object,
  Observable_default as Observable,
  Overlay_default as Overlay,
  PluggableMap_default as PluggableMap,
  Tile_default as Tile,
  TileCache_default as TileCache,
  TileQueue_default as TileQueue,
  TileRange_default as TileRange,
  VERSION,
  VectorRenderTile_default as VectorRenderTile,
  VectorTile_default as VectorTile,
  View_default as View,
  getUid
};
//# sourceMappingURL=ol.js.map
